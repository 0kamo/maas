{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/maasserver/static/js/angular/3rdparty/ng-tags-input.js","webpack:///./src/maasserver/static/js/angular/3rdparty/vs-repeat.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","KEYS","SUPPORTED_INPUT_TYPES","tagsInput","angular","directive","$timeout","$document","$window","tagsInputConfig","tiUtil","validateType","type","indexOf","restrict","require","scope","tags","onTagAdding","onTagAdded","onInvalidTag","onTagRemoving","onTagRemoved","replace","transclude","templateUrl","controller","$scope","$attrs","$element","events","simplePubSub","load","template","String","placeholder","tabindex","Number","removeTagSymbol","fromCharCode","replaceSpacesWithDashes","Boolean","minLength","maxLength","addOnEnter","addOnSpace","addOnComma","addOnBlur","addOnPaste","pasteSplitPattern","RegExp","allowedTagsPattern","enableEditingLastTag","minTags","maxTags","displayProperty","keyProperty","allowLeftoverText","addFromAutocompleteOnly","spellcheck","tagList","options","getTagText","setTagText","tagIsValid","self","tag","safeToString","text","tagText","length","test","findInObjectArray","items","$tag","addText","add","push","trigger","remove","index","splice","clearSelection","select","selected","selectPrior","selectNext","removeSelected","handleUndefinedResult","this","registerAutocomplete","find","addTag","focusInput","getTags","getCurrentTagText","newTag","getOptions","on","handler","registerTagItem","removeTag","disabled","link","element","attrs","ngModelCtrl","setElementValidity","hotkeys","input","validationOptions","$setValidity","hasFocus","$isEmpty","invalid","setText","track","$watch","makeObjectArray","$observe","eventHandlers","change","keydown","$event","focus","blur","activeElement","prop","lostFocusToBrowserWindow","lostFocusToChildElement","contains","paste","getTextData","clipboardData","originalEvent","getData","host","click","$setViewValue","e","triggerHandler","event","shouldAdd","shouldRemove","shouldSelect","shouldEditLastTag","key","keyCode","addKeys","shiftKey","altKey","ctrlKey","metaKey","preventDefault","split","forEach","data","tagsInputCtrl","$$template","$$removeTagSymbol","$getDisplayText","$removeTag","$index","$sce","$q","source","debounceDelay","highlightMatchedText","maxResultsToShow","loadOnDownArrow","loadOnEmpty","loadOnFocus","selectFirstMatch","suggestionList","loadFn","getDifference","lastPromise","getTagId","array1","array2","filter","item","a","b","defaultComparer","reset","visible","query","show","debounce","promise","when","$query","then","slice","registerAutocompleteMatch","getQuery","shouldLoadSuggestions","addSuggestionByIndex","addSuggestion","added","copy","handled","stopImmediatePropagation","root","eq","parent","elementTop","elementHeight","parentHeight","parentScrollTop","scrollToElement","autoCompleteCtrl","autoComplete","$parent","$highlight","safeHighlight","trustAsHtml","ctrl","transcludeFn","clone","append","span","resize","threshold","getTextAutosizeThreshold","css","originalValue","width","isString","$parsers","unshift","$formatters","$modelValue","tiBindAttrs","$set","provider","globalDefaults","interpolationStatus","autosizeThreshold","setDefaults","defaults","setActiveInterpolation","setTextAutosizeThreshold","$get","$interpolate","converters","parseInt","toLowerCase","defaultValidator","localDefault","validator","converter","getDefault","updateValue","globalValue","isDefined","newValue","factory","fn","delay","timeoutId","args","arguments","cancel","apply","array","isObject","obj","comparer","some","str","encodeHTML","expression","escapeRegexChars","match","isUndefined","toString","trim","valueIfUndefined","result","names","every","run","$templateCache","put","window","dde","document","documentElement","matchingFunction","matches","matchesSelector","webkitMatches","webkitMatchesSelector","msMatches","msMatchesSelector","mozMatches","mozMatchesSelector","closestElement","closest","selector","el","parentNode","getWindowScroll","scrollTop","pageYOffset","scrollLeft","pageXOffset","sx","body","getClientSize","sizeProp","innerWidth","innerHeight","vsRepeatModule","$compile","$parse","compile","ngRepeatExpression","expressionMatches","lhs","rhs","rhsSuffix","originalNgRepeatAttr","repeatContainer","vsRepeatContainer","querySelector","ngRepeatChild","children","childCloneHtml","outerHTML","collectionName","isNgRepeatStart","attributesDictionary","vsRepeat","vsOffsetBefore","vsOffsetAfter","vsScrolledToEndOffset","vsScrolledToBeginningOffset","vsExcess","vsScrollMargin","attr","Error","exec","repeaterElement","empty","pre","originalLength","_prevStartIndex","_prevEndIndex","_minStartIndex","_maxEndIndex","_prevClientSize","childClone","childTagName","tagName","originalCollection","$$horizontal","vsHorizontal","$beforeContent","$afterContent","autoSize","sizesPropertyExists","vsSize","vsSizeProperty","$scrollParent","vsScrollParent","$$options","$eval","vsOptions","clientSize","offsetSize","scrollPos","totalSize","console","warn","refresh","sizesCumulative","sizes","map","$new","extend","size","elementSize","$destroy","sum","res","setAutoSize","reinitialize","$$postDigest","offsetHeight","offsetWidth","gotSomething","insideStartEndSequence","attributes","$root","$$phase","$apply","dereg","getLayoutProp","layoutPropPrefix","scrollHandler","updateInnerCollection","$digest","expectedSize","clientHeight","onWindowResize","vsAutoresize","offsetBefore","offsetAfter","$emit","startIndex","endIndex","reinitOnClientHeightChange","ch","scrollProp","vsElement","scrollElement","isHorizontal","$scrollPosition","$clientSize","scrollOffset","getBoundingClientRect","__startIndex","__endIndex","scrollMargin","Math","max","floor","excess","min","ceil","latch","digestRequired","hunked","abs","triggerIndex","vsScrolledToEnd","scrolledToEndOffset","vsScrolledToBeginning","scrolledToBeginningOffset","parsed","o1","o2","total","keys","$watchCollection","coll","addClass","$on","off","setTimeout","requestAnimationFrame"],"mappings":"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","file":"vendor-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n * ngTagsInput v2.3.0\n * http://mbenford.github.io/ngTagsInput\n *\n * Copyright (c) 2013-2015 Michael Benford\n * License: MIT\n *\n * Generated at 2015-03-24 00:49:44 -0300\n */\n(function() {\n'use strict';\n\nvar KEYS = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    left: 37,\n    right: 39,\n    delete: 46,\n    comma: 188\n};\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar SUPPORTED_INPUT_TYPES = ['text', 'email', 'url'];\n\nvar tagsInput = angular.module('ngTagsInput', []);\n\n/**\n * @ngdoc directive\n * @name tagsInput\n * @module ngTagsInput\n *\n * @description\n * Renders an input box with tag editing support.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} [displayProperty=text] Property to be rendered as the tag label.\n * @param {string=} [keyProperty=text] Property to be used as a unique identifier for the tag.\n * @param {string=} [type=text] Type of the input element. Only 'text', 'email' and 'url' are supported values.\n * @param {number=} tabindex Tab order of the control.\n * @param {string=} [placeholder=Add a tag] Placeholder text for the control.\n * @param {number=} [minLength=3] Minimum length for a new tag.\n * @param {number=} [maxLength=MAX_SAFE_INTEGER] Maximum length allowed for a new tag.\n * @param {number=} [minTags=0] Sets minTags validation error key if the number of tags added is less than minTags.\n * @param {number=} [maxTags=MAX_SAFE_INTEGER] Sets maxTags validation error key if the number of tags added is greater than maxTags.\n * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in\n *                                             the input element when the directive loses focus.\n * @param {string=} [removeTagSymbol=×] Symbol character for the remove tag button.\n * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.\n * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.\n * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.\n * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.\n * @param {boolean=} [addOnPaste=false] Flag indicating that the text pasted into the input field will be split into tags.\n * @param {string=} [pasteSplitPattern=,] Regular expression used to split the pasted text into tags.\n * @param {boolean=} [replaceSpacesWithDashes=true] Flag indicating that spaces will be replaced with dashes.\n * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.\n * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into\n *                                                the new tag input box instead of being removed when the backspace key\n *                                                is pressed and the input box is empty.\n * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.\n *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and\n *                                                   allowLeftoverText values are ignored.\n * @param {boolean=} [spellcheck=true] Flag indicating whether the browser's spellcheck is enabled for the input field or not.\n * @param {expression} onTagAdding Expression to evaluate that will be invoked before adding a new tag. The new tag is available as $tag. This method must return either true or false. If false, the tag will not be added.\n * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n * @param {expression} onInvalidTag Expression to evaluate when a tag is invalid. The invalid tag is available as $tag.\n * @param {expression} onTagRemoving Expression to evaluate that will be invoked before removing a tag. The tag is available as $tag. This method must return either true or false. If false, the tag will not be removed.\n * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n */\ntagsInput.directive('tagsInput', [\"$timeout\",\"$document\",\"$window\",\"tagsInputConfig\",\"tiUtil\", function($timeout, $document, $window, tagsInputConfig, tiUtil) {\n    function TagList(options, events, onTagAdding, onTagRemoving) {\n        var self = {}, getTagText, setTagText, tagIsValid;\n\n        getTagText = function(tag) {\n            return tiUtil.safeToString(tag[options.displayProperty]);\n        };\n\n        setTagText = function(tag, text) {\n            tag[options.displayProperty] = text;\n        };\n\n        tagIsValid = function(tag) {\n            var tagText = getTagText(tag);\n\n            return tagText &&\n                   tagText.length >= options.minLength &&\n                   tagText.length <= options.maxLength &&\n                   options.allowedTagsPattern.test(tagText) &&\n                   !tiUtil.findInObjectArray(self.items, tag, options.keyProperty || options.displayProperty) &&\n                   onTagAdding({ $tag: tag });\n        };\n\n        self.items = [];\n\n        self.addText = function(text) {\n            var tag = {};\n            setTagText(tag, text);\n            return self.add(tag);\n        };\n\n        self.add = function(tag) {\n            var tagText = getTagText(tag);\n\n            if (options.replaceSpacesWithDashes) {\n                tagText = tiUtil.replaceSpacesWithDashes(tagText);\n            }\n\n            setTagText(tag, tagText);\n\n            if (tagIsValid(tag)) {\n                self.items.push(tag);\n                events.trigger('tag-added', { $tag: tag });\n            }\n            else if (tagText) {\n                events.trigger('invalid-tag', { $tag: tag });\n            }\n\n            return tag;\n        };\n\n        self.remove = function(index) {\n            var tag = self.items[index];\n\n            if (onTagRemoving({ $tag: tag }))  {\n                self.items.splice(index, 1);\n                self.clearSelection();\n                events.trigger('tag-removed', { $tag: tag });\n                return tag;\n            }\n        };\n\n        self.select = function(index) {\n            if (index < 0) {\n                index = self.items.length - 1;\n            }\n            else if (index >= self.items.length) {\n                index = 0;\n            }\n\n            self.index = index;\n            self.selected = self.items[index];\n        };\n\n        self.selectPrior = function() {\n            self.select(--self.index);\n        };\n\n        self.selectNext = function() {\n            self.select(++self.index);\n        };\n\n        self.removeSelected = function() {\n            return self.remove(self.index);\n        };\n\n        self.clearSelection = function() {\n            self.selected = null;\n            self.index = -1;\n        };\n\n        self.clearSelection();\n\n        return self;\n    }\n\n    function validateType(type) {\n        return SUPPORTED_INPUT_TYPES.indexOf(type) !== -1;\n    }\n\n    return {\n        restrict: 'E',\n        require: 'ngModel',\n        scope: {\n            tags: '=ngModel',\n            onTagAdding: '&',\n            onTagAdded: '&',\n            onInvalidTag: '&',\n            onTagRemoving: '&',\n            onTagRemoved: '&'\n        },\n        replace: false,\n        transclude: true,\n        templateUrl: 'ngTagsInput/tags-input.html',\n        controller: [\"$scope\",\"$attrs\",\"$element\", function($scope, $attrs, $element) {\n            $scope.events = tiUtil.simplePubSub();\n\n            tagsInputConfig.load('tagsInput', $scope, $attrs, {\n                template: [String, 'ngTagsInput/tag-item.html'],\n                type: [String, 'text', validateType],\n                placeholder: [String, 'Add a tag'],\n                tabindex: [Number, null],\n                removeTagSymbol: [String, String.fromCharCode(215)],\n                replaceSpacesWithDashes: [Boolean, true],\n                minLength: [Number, 3],\n                maxLength: [Number, MAX_SAFE_INTEGER],\n                addOnEnter: [Boolean, true],\n                addOnSpace: [Boolean, false],\n                addOnComma: [Boolean, true],\n                addOnBlur: [Boolean, true],\n                addOnPaste: [Boolean, false],\n                pasteSplitPattern: [RegExp, /,/],\n                allowedTagsPattern: [RegExp, /.+/],\n                enableEditingLastTag: [Boolean, false],\n                minTags: [Number, 0],\n                maxTags: [Number, MAX_SAFE_INTEGER],\n                displayProperty: [String, 'text'],\n                keyProperty: [String, ''],\n                allowLeftoverText: [Boolean, false],\n                addFromAutocompleteOnly: [Boolean, false],\n                spellcheck: [Boolean, true]\n            });\n\n            $scope.tagList = new TagList($scope.options, $scope.events,\n                tiUtil.handleUndefinedResult($scope.onTagAdding, true),\n                tiUtil.handleUndefinedResult($scope.onTagRemoving, true));\n\n            this.registerAutocomplete = function() {\n                var input = $element.find('input');\n\n                return {\n                    addTag: function(tag) {\n                        return $scope.tagList.add(tag);\n                    },\n                    focusInput: function() {\n                        // blake_r - Stop the focus as this breaks on the\n                        // version of AngularJS that ships with MAAS.\n                        //input[0].focus();\n                    },\n                    getTags: function() {\n                        return $scope.tags;\n                    },\n                    getCurrentTagText: function() {\n                        return $scope.newTag.text;\n                    },\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    on: function(name, handler) {\n                        $scope.events.on(name, handler);\n                        return this;\n                    }\n                };\n            };\n\n            this.registerTagItem = function() {\n                return {\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    removeTag: function(index) {\n                        if ($scope.disabled) {\n                            return;\n                        }\n                        $scope.tagList.remove(index);\n                    }\n                };\n            };\n        }],\n        link: function(scope, element, attrs, ngModelCtrl) {\n            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace, KEYS.delete, KEYS.left, KEYS.right],\n                tagList = scope.tagList,\n                events = scope.events,\n                options = scope.options,\n                input = element.find('input'),\n                validationOptions = ['minTags', 'maxTags', 'allowLeftoverText'],\n                setElementValidity;\n\n            setElementValidity = function() {\n                ngModelCtrl.$setValidity('maxTags', scope.tags.length <= options.maxTags);\n                ngModelCtrl.$setValidity('minTags', scope.tags.length >= options.minTags);\n                ngModelCtrl.$setValidity('leftoverText', scope.hasFocus || options.allowLeftoverText ? true : !scope.newTag.text);\n            };\n\n            ngModelCtrl.$isEmpty = function(value) {\n                return !value || !value.length;\n            };\n\n            scope.newTag = {\n                text: '',\n                invalid: null,\n                setText: function(value) {\n                    this.text = value;\n                    events.trigger('input-change', value);\n                }\n            };\n\n            scope.track = function(tag) {\n                return tag[options.keyProperty || options.displayProperty];\n            };\n\n            scope.$watch('tags', function(value) {\n                scope.tags = tiUtil.makeObjectArray(value, options.displayProperty);\n                tagList.items = scope.tags;\n            });\n\n            scope.$watch('tags.length', function() {\n                setElementValidity();\n            });\n\n            attrs.$observe('disabled', function(value) {\n                scope.disabled = value;\n            });\n\n            scope.eventHandlers = {\n                input: {\n                    change: function(text) {\n                        events.trigger('input-change', text);\n                    },\n                    keydown: function($event) {\n                        events.trigger('input-keydown', $event);\n                    },\n                    focus: function() {\n                        if (scope.hasFocus) {\n                            return;\n                        }\n\n                        scope.hasFocus = true;\n                        events.trigger('input-focus');\n                    },\n                    blur: function() {\n                        $timeout(function() {\n                            var activeElement = $document.prop('activeElement'),\n                                lostFocusToBrowserWindow = activeElement === input[0],\n                                lostFocusToChildElement = element[0].contains(activeElement);\n\n                            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {\n                                scope.hasFocus = false;\n                                events.trigger('input-blur');\n                            }\n                        });\n                    },\n                    paste: function($event) {\n                        $event.getTextData = function() {\n                            var clipboardData = $event.clipboardData || ($event.originalEvent && $event.originalEvent.clipboardData);\n                            return clipboardData ? clipboardData.getData('text/plain') : $window.clipboardData.getData('Text');\n                        };\n                        events.trigger('input-paste', $event);\n                    }\n                },\n                host: {\n                    click: function() {\n                        if (scope.disabled) {\n                            return;\n                        }\n                        // blake_r - Stop the focus as this breaks on the\n                        // version of AngularJS that ships with MAAS.\n                        //input[0].focus();\n                    }\n                }\n            };\n\n            events\n                .on('tag-added', scope.onTagAdded)\n                .on('invalid-tag', scope.onInvalidTag)\n                .on('tag-removed', scope.onTagRemoved)\n                .on('tag-added', function() {\n                    scope.newTag.setText('');\n                })\n                .on('tag-added tag-removed', function() {\n                    // Sets the element to its dirty state\n                    // In Angular 1.3 this will be replaced with $setDirty.\n                    ngModelCtrl.$setViewValue(scope.tags);\n                })\n                .on('invalid-tag', function() {\n                    scope.newTag.invalid = true;\n                })\n                .on('option-change', function(e) {\n                    if (validationOptions.indexOf(e.name) !== -1) {\n                        setElementValidity();\n                    }\n                })\n                .on('input-change', function() {\n                    tagList.clearSelection();\n                    scope.newTag.invalid = null;\n                })\n                .on('input-focus', function() {\n                    element.triggerHandler('focus');\n                    ngModelCtrl.$setValidity('leftoverText', true);\n                })\n                .on('input-blur', function() {\n                    if (options.addOnBlur && !options.addFromAutocompleteOnly) {\n                        tagList.addText(scope.newTag.text);\n                    }\n                    element.triggerHandler('blur');\n                    setElementValidity();\n                })\n                .on('input-keydown', function(event) {\n                    var key = event.keyCode,\n                        isModifier = event.shiftKey || event.altKey || event.ctrlKey || event.metaKey,\n                        addKeys = {},\n                        shouldAdd, shouldRemove, shouldSelect, shouldEditLastTag;\n\n                    if (isModifier || hotkeys.indexOf(key) === -1) {\n                        return;\n                    }\n\n                    addKeys[KEYS.enter] = options.addOnEnter;\n                    addKeys[KEYS.comma] = options.addOnComma;\n                    addKeys[KEYS.space] = options.addOnSpace;\n\n                    shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];\n                    shouldRemove = (key === KEYS.backspace || key === KEYS.delete) && tagList.selected;\n                    shouldEditLastTag = key === KEYS.backspace && scope.newTag.text.length === 0 && options.enableEditingLastTag;\n                    shouldSelect = (key === KEYS.backspace || key === KEYS.left || key === KEYS.right) && scope.newTag.text.length === 0 && !options.enableEditingLastTag;\n\n                    if (shouldAdd) {\n                        tagList.addText(scope.newTag.text);\n                    }\n                    else if (shouldEditLastTag) {\n                        var tag;\n\n                        tagList.selectPrior();\n                        tag = tagList.removeSelected();\n\n                        if (tag) {\n                            scope.newTag.setText(tag[options.displayProperty]);\n                        }\n                    }\n                    else if (shouldRemove) {\n                        tagList.removeSelected();\n                    }\n                    else if (shouldSelect) {\n                        if (key === KEYS.left || key === KEYS.backspace) {\n                            tagList.selectPrior();\n                        }\n                        else if (key === KEYS.right) {\n                            tagList.selectNext();\n                        }\n                    }\n\n                    if (shouldAdd || shouldSelect || shouldRemove || shouldEditLastTag) {\n                        event.preventDefault();\n                    }\n                })\n                .on('input-paste', function(event) {\n                    if (options.addOnPaste) {\n                        var data = event.getTextData();\n                        var tags = data.split(options.pasteSplitPattern);\n\n                        if (tags.length > 1) {\n                            tags.forEach(function(tag) {\n                                tagList.addText(tag);\n                            });\n                            event.preventDefault();\n                        }\n                    }\n                });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiTagItem\n * @module ngTagsInput\n *\n * @description\n * Represents a tag item. Used internally by the tagsInput directive.\n */\ntagsInput.directive('tiTagItem', [\"tiUtil\", function(tiUtil) {\n    return {\n        restrict: 'E',\n        require: '^tagsInput',\n        template: '<ng-include src=\"$$template\"></ng-include>',\n        scope: { data: '=' },\n        link: function(scope, element, attrs, tagsInputCtrl) {\n            var tagsInput = tagsInputCtrl.registerTagItem(),\n                options = tagsInput.getOptions();\n\n            scope.$$template = options.template;\n            scope.$$removeTagSymbol = options.removeTagSymbol;\n\n            scope.$getDisplayText = function() {\n                return tiUtil.safeToString(scope.data[options.displayProperty]);\n            };\n            scope.$removeTag = function() {\n                tagsInput.removeTag(scope.$index);\n            };\n\n            scope.$watch('$parent.$index', function(value) {\n                scope.$index = value;\n            });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name autoComplete\n * @module ngTagsInput\n *\n * @description\n * Provides autocomplete support for the tagsInput directive.\n *\n * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as\n *                            $query. The result of the expression must be a promise that eventually resolves to an\n *                            array of strings.\n * @param {string=} [displayProperty=text] Property to be rendered as the autocomplete label.\n * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in\n *                                      the source option after the last keystroke.\n * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression\n *                                 in the source option.\n * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the\n *                                               suggestions list.\n * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.\n * @param {boolean=} [loadOnDownArrow=false] Flag indicating that the source option will be evaluated when the down arrow\n *                                           key is pressed and the suggestion list is closed. The current input value\n *                                           is available as $query.\n * @param {boolean=} {loadOnEmpty=false} Flag indicating that the source option will be evaluated when the input content\n *                                       becomes empty. The $query variable will be passed to the expression as an empty string.\n * @param {boolean=} {loadOnFocus=false} Flag indicating that the source option will be evaluated when the input element\n *                                       gains focus. The current input value is available as $query.\n * @param {boolean=} [selectFirstMatch=true] Flag indicating that the first match will be automatically selected once\n *                                           the suggestion list is shown.\n * @param {string=} [template=] URL or id of a custom template for rendering each element of the autocomplete list.\n */\ntagsInput.directive('autoComplete', [\"$document\",\"$timeout\",\"$sce\",\"$q\",\"tagsInputConfig\",\"tiUtil\", function($document, $timeout, $sce, $q, tagsInputConfig, tiUtil) {\n    function SuggestionList(loadFn, options, events) {\n        var self = {}, getDifference, lastPromise, getTagId;\n\n        getTagId = function() {\n            return options.tagsInput.keyProperty || options.tagsInput.displayProperty;\n        };\n\n        getDifference = function(array1, array2) {\n            return array1.filter(function(item) {\n                return !tiUtil.findInObjectArray(array2, item, getTagId(), function(a, b) {\n                    if (options.tagsInput.replaceSpacesWithDashes) {\n                        a = tiUtil.replaceSpacesWithDashes(a);\n                        b = tiUtil.replaceSpacesWithDashes(b);\n                    }\n                    return tiUtil.defaultComparer(a, b);\n                });\n            });\n        };\n\n        self.reset = function() {\n            lastPromise = null;\n\n            self.items = [];\n            self.visible = false;\n            self.index = -1;\n            self.selected = null;\n            self.query = null;\n        };\n        self.show = function() {\n            if (options.selectFirstMatch) {\n                self.select(0);\n            }\n            else {\n                self.selected = null;\n            }\n            self.visible = true;\n        };\n        self.load = tiUtil.debounce(function(query, tags) {\n            self.query = query;\n\n            var promise = $q.when(loadFn({ $query: query }));\n            lastPromise = promise;\n\n            promise.then(function(items) {\n                if (promise !== lastPromise) {\n                    return;\n                }\n\n                items = tiUtil.makeObjectArray(items.data || items, getTagId());\n                items = getDifference(items, tags);\n                self.items = items.slice(0, options.maxResultsToShow);\n\n                if (self.items.length > 0) {\n                    self.show();\n                }\n                else {\n                    self.reset();\n                }\n            });\n        }, options.debounceDelay);\n\n        self.selectNext = function() {\n            self.select(++self.index);\n        };\n        self.selectPrior = function() {\n            self.select(--self.index);\n        };\n        self.select = function(index) {\n            if (index < 0) {\n                index = self.items.length - 1;\n            }\n            else if (index >= self.items.length) {\n                index = 0;\n            }\n            self.index = index;\n            self.selected = self.items[index];\n            events.trigger('suggestion-selected', index);\n        };\n\n        self.reset();\n\n        return self;\n    }\n\n    function scrollToElement(root, index) {\n        var element = root.find('li').eq(index),\n            parent = element.parent(),\n            elementTop = element.prop('offsetTop'),\n            elementHeight = element.prop('offsetHeight'),\n            parentHeight = parent.prop('clientHeight'),\n            parentScrollTop = parent.prop('scrollTop');\n\n        if (elementTop < parentScrollTop) {\n            parent.prop('scrollTop', elementTop);\n        }\n        else if (elementTop + elementHeight > parentHeight + parentScrollTop) {\n            parent.prop('scrollTop', elementTop + elementHeight - parentHeight);\n        }\n    }\n\n    return {\n        restrict: 'E',\n        require: '^tagsInput',\n        scope: { source: '&' },\n        templateUrl: 'ngTagsInput/auto-complete.html',\n        controller: [\"$scope\",\"$element\",\"$attrs\", function($scope, $element, $attrs) {\n            $scope.events = tiUtil.simplePubSub();\n\n            tagsInputConfig.load('autoComplete', $scope, $attrs, {\n                template: [String, 'ngTagsInput/auto-complete-match.html'],\n                debounceDelay: [Number, 100],\n                minLength: [Number, 3],\n                highlightMatchedText: [Boolean, true],\n                maxResultsToShow: [Number, 10],\n                loadOnDownArrow: [Boolean, false],\n                loadOnEmpty: [Boolean, false],\n                loadOnFocus: [Boolean, false],\n                selectFirstMatch: [Boolean, true],\n                displayProperty: [String, '']\n            });\n\n            $scope.suggestionList = new SuggestionList($scope.source, $scope.options, $scope.events);\n\n            this.registerAutocompleteMatch = function() {\n                return {\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    getQuery: function() {\n                        return $scope.suggestionList.query;\n                    }\n                };\n            };\n        }],\n        link: function(scope, element, attrs, tagsInputCtrl) {\n            var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],\n                suggestionList = scope.suggestionList,\n                tagsInput = tagsInputCtrl.registerAutocomplete(),\n                options = scope.options,\n                events = scope.events,\n                shouldLoadSuggestions;\n\n            options.tagsInput = tagsInput.getOptions();\n\n            shouldLoadSuggestions = function(value) {\n                return value && value.length >= options.minLength || !value && options.loadOnEmpty;\n            };\n\n            scope.addSuggestionByIndex = function(index) {\n                suggestionList.select(index);\n                scope.addSuggestion();\n            };\n\n            scope.addSuggestion = function() {\n                var added = false;\n\n                if (suggestionList.selected) {\n                    tagsInput.addTag(angular.copy(suggestionList.selected));\n                    suggestionList.reset();\n                    tagsInput.focusInput();\n\n                    added = true;\n                }\n                return added;\n            };\n\n            scope.track = function(item) {\n                return item[options.tagsInput.keyProperty || options.tagsInput.displayProperty];\n            };\n\n            tagsInput\n                .on('tag-added invalid-tag input-blur', function() {\n                    suggestionList.reset();\n                })\n                .on('input-change', function(value) {\n                    if (shouldLoadSuggestions(value)) {\n                        suggestionList.load(value, tagsInput.getTags());\n                    }\n                    else {\n                        suggestionList.reset();\n                    }\n                })\n                .on('input-focus', function() {\n                    var value = tagsInput.getCurrentTagText();\n                    if (options.loadOnFocus && shouldLoadSuggestions(value)) {\n                        suggestionList.load(value, tagsInput.getTags());\n                    }\n                })\n                .on('input-keydown', function(event) {\n                    var key = event.keyCode,\n                        handled = false;\n\n                    if (hotkeys.indexOf(key) === -1) {\n                        return;\n                    }\n\n                    if (suggestionList.visible) {\n\n                        if (key === KEYS.down) {\n                            suggestionList.selectNext();\n                            handled = true;\n                        }\n                        else if (key === KEYS.up) {\n                            suggestionList.selectPrior();\n                            handled = true;\n                        }\n                        else if (key === KEYS.escape) {\n                            suggestionList.reset();\n                            handled = true;\n                        }\n                        else if (key === KEYS.enter || key === KEYS.tab) {\n                            handled = scope.addSuggestion();\n                        }\n                    }\n                    else {\n                        if (key === KEYS.down && scope.options.loadOnDownArrow) {\n                            suggestionList.load(tagsInput.getCurrentTagText(), tagsInput.getTags());\n                            handled = true;\n                        }\n                    }\n\n                    if (handled) {\n                        event.preventDefault();\n                        event.stopImmediatePropagation();\n                        return false;\n                    }\n                });\n\n            events.on('suggestion-selected', function(index) {\n                scrollToElement(element, index);\n            });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiAutocompleteMatch\n * @module ngTagsInput\n *\n * @description\n * Represents an autocomplete match. Used internally by the autoComplete directive.\n */\ntagsInput.directive('tiAutocompleteMatch', [\"$sce\",\"tiUtil\", function($sce, tiUtil) {\n    return {\n        restrict: 'E',\n        require: '^autoComplete',\n        template: '<ng-include src=\"$$template\"></ng-include>',\n        scope: { data: '=' },\n        link: function(scope, element, attrs, autoCompleteCtrl) {\n            var autoComplete = autoCompleteCtrl.registerAutocompleteMatch(),\n                options = autoComplete.getOptions();\n\n            scope.$$template = options.template;\n            scope.$index = scope.$parent.$index;\n\n            scope.$highlight = function(text) {\n                if (options.highlightMatchedText) {\n                    text = tiUtil.safeHighlight(text, autoComplete.getQuery());\n                }\n                return $sce.trustAsHtml(text);\n            };\n            scope.$getDisplayText =  function() {\n                return tiUtil.safeToString(scope.data[options.displayProperty || options.tagsInput.displayProperty]);\n            };\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiTranscludeAppend\n * @module ngTagsInput\n *\n * @description\n * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiTranscludeAppend', function() {\n    return function(scope, element, attrs, ctrl, transcludeFn) {\n        transcludeFn(function(clone) {\n            element.append(clone);\n        });\n    };\n});\n\n/**\n * @ngdoc directive\n * @name tiAutosize\n * @module ngTagsInput\n *\n * @description\n * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiAutosize', [\"tagsInputConfig\", function(tagsInputConfig) {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function(scope, element, attrs, ctrl) {\n            var threshold = tagsInputConfig.getTextAutosizeThreshold(),\n                span, resize;\n\n            span = angular.element('<span class=\"input\"></span>');\n            span.css('display', 'none')\n                .css('visibility', 'hidden')\n                .css('width', 'auto')\n                .css('white-space', 'pre');\n\n            element.parent().append(span);\n\n            resize = function(originalValue) {\n                var value = originalValue, width;\n\n                if (angular.isString(value) && value.length === 0) {\n                    value = attrs.placeholder;\n                }\n\n                if (value) {\n                    span.text(value);\n                    span.css('display', '');\n                    width = span.prop('offsetWidth');\n                    span.css('display', 'none');\n                }\n\n                element.css('width', width ? width + threshold + 'px' : '');\n\n                return originalValue;\n            };\n\n            ctrl.$parsers.unshift(resize);\n            ctrl.$formatters.unshift(resize);\n\n            attrs.$observe('placeholder', function(value) {\n                if (!ctrl.$modelValue) {\n                    resize(value);\n                }\n            });\n        }\n    };\n}]);\n\n/**\n * @ngdoc directive\n * @name tiBindAttrs\n * @module ngTagsInput\n *\n * @description\n * Binds attributes to expressions. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiBindAttrs', function() {\n    return function(scope, element, attrs) {\n        scope.$watch(attrs.tiBindAttrs, function(value) {\n            angular.forEach(value, function(value, key) {\n                /**\n                 * blake_r - Added to work around the version of jQuery that\n                 * MAAS currently ships with. Once packaging for jQuery is\n                 * version >1.9 this can be removed.\n                 */\n                if(key === \"type\") {\n                    element[0].type = value;\n                } else {\n                    attrs.$set(key, value);\n                }\n            });\n        }, true);\n    };\n});\n\n/**\n * @ngdoc service\n * @name tagsInputConfig\n * @module ngTagsInput\n *\n * @description\n * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and\n * initialize options from HTML attributes.\n */\ntagsInput.provider('tagsInputConfig', function() {\n    var globalDefaults = {},\n        interpolationStatus = {},\n        autosizeThreshold = 3;\n\n    /**\n     * @ngdoc method\n     * @name setDefaults\n     * @description Sets the default configuration option for a directive.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} defaults Object containing options and their values.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setDefaults = function(directive, defaults) {\n        globalDefaults[directive] = defaults;\n        return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setActiveInterpolation\n     * @description Sets active interpolation for a set of options.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} options Object containing which options should have interpolation turned on at all times.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setActiveInterpolation = function(directive, options) {\n        interpolationStatus[directive] = options;\n        return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setTextAutosizeThreshold\n     * @description Sets the threshold used by the tagsInput directive to re-size the inner input field element based on its contents.\n     * @methodOf tagsInputConfig\n     *\n     * @param {number} threshold Threshold value, in pixels.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setTextAutosizeThreshold = function(threshold) {\n        autosizeThreshold = threshold;\n        return this;\n    };\n\n    this.$get = [\"$interpolate\", function($interpolate) {\n        var converters = {};\n        converters[String] = function(value) { return value; };\n        converters[Number] = function(value) { return parseInt(value, 10); };\n        converters[Boolean] = function(value) { return value.toLowerCase() === 'true'; };\n        converters[RegExp] = function(value) { return new RegExp(value); };\n\n        return {\n            load: function(directive, scope, attrs, options) {\n                var defaultValidator = function() { return true; };\n\n                scope.options = {};\n\n                angular.forEach(options, function(value, key) {\n                    var type, localDefault, validator, converter, getDefault, updateValue;\n\n                    type = value[0];\n                    localDefault = value[1];\n                    validator = value[2] || defaultValidator;\n                    converter = converters[type];\n\n                    getDefault = function() {\n                        var globalValue = globalDefaults[directive] && globalDefaults[directive][key];\n                        return angular.isDefined(globalValue) ? globalValue : localDefault;\n                    };\n\n                    updateValue = function(value) {\n                        scope.options[key] = value && validator(value) ? converter(value) : getDefault();\n                    };\n\n                    if (interpolationStatus[directive] && interpolationStatus[directive][key]) {\n                        attrs.$observe(key, function(value) {\n                            updateValue(value);\n                            scope.events.trigger('option-change', { name: key, newValue: value });\n                        });\n                    }\n                    else {\n                        updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));\n                    }\n                });\n            },\n            getTextAutosizeThreshold: function() {\n                return autosizeThreshold;\n            }\n        };\n    }];\n});\n\n\n/***\n * @ngdoc factory\n * @name tiUtil\n * @module ngTagsInput\n *\n * @description\n * Helper methods used internally by the directive. Should not be called directly from user code.\n */\ntagsInput.factory('tiUtil', [\"$timeout\", function($timeout) {\n    var self = {};\n\n    self.debounce = function(fn, delay) {\n        var timeoutId;\n        return function() {\n            var args = arguments;\n            $timeout.cancel(timeoutId);\n            timeoutId = $timeout(function() { fn.apply(null, args); }, delay);\n        };\n    };\n\n    self.makeObjectArray = function(array, key) {\n        array = array || [];\n        if (array.length > 0 && !angular.isObject(array[0])) {\n            array.forEach(function(item, index) {\n                array[index] = {};\n                array[index][key] = item;\n            });\n        }\n        return array;\n    };\n\n    self.findInObjectArray = function(array, obj, key, comparer) {\n        var item = null;\n        comparer = comparer || self.defaultComparer;\n\n        array.some(function(element) {\n            if (comparer(element[key], obj[key])) {\n                item = element;\n                return true;\n            }\n        });\n\n        return item;\n    };\n\n    self.defaultComparer = function(a, b) {\n        // I'm aware of the internationalization issues regarding toLowerCase()\n        // but I couldn't come up with a better solution right now\n        return self.safeToString(a).toLowerCase() === self.safeToString(b).toLowerCase();\n    };\n\n    self.safeHighlight = function(str, value) {\n        if (!value) {\n            return str;\n        }\n\n        function escapeRegexChars(str) {\n            return str.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n        }\n\n        str = self.encodeHTML(str);\n        value = self.encodeHTML(value);\n\n        var expression = new RegExp('&[^;]+;|' + escapeRegexChars(value), 'gi');\n        return str.replace(expression, function(match) {\n            return match.toLowerCase() === value.toLowerCase() ? '<em>' + match + '</em>' : match;\n        });\n    };\n\n    self.safeToString = function(value) {\n        return angular.isUndefined(value) || value == null ? '' : value.toString().trim();\n    };\n\n    self.encodeHTML = function(value) {\n        return self.safeToString(value)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    };\n\n    self.handleUndefinedResult = function(fn, valueIfUndefined) {\n        return function() {\n            var result = fn.apply(null, arguments);\n            return angular.isUndefined(result) ? valueIfUndefined : result;\n        };\n    };\n\n    self.replaceSpacesWithDashes = function(str) {\n        return self.safeToString(str).replace(/\\s/g, '-');\n    };\n\n    self.simplePubSub = function() {\n        var events = {};\n        return {\n            on: function(names, handler) {\n                names.split(' ').forEach(function(name) {\n                    if (!events[name]) {\n                        events[name] = [];\n                    }\n                    events[name].push(handler);\n                });\n                return this;\n            },\n            trigger: function(name, args) {\n                var handlers = events[name] || [];\n                handlers.every(function(handler) {\n                    return self.handleUndefinedResult(handler, true)(args);\n                });\n                return this;\n            }\n        };\n    };\n\n    return self;\n}]);\n\n/* HTML templates */\ntagsInput.run([\"$templateCache\", function($templateCache) {\n    $templateCache.put('ngTagsInput/tags-input.html',\n    \"<div class=\\\"host\\\" tabindex=\\\"-1\\\" data-ng-click=\\\"eventHandlers.host.click()\\\" ti-transclude-append=\\\"\\\"><div class=\\\"tags\\\" data-ng-class=\\\"{focused: hasFocus}\\\"><ul class=\\\"tag-list\\\"><li class=\\\"tag-item\\\" data-ng-repeat=\\\"tag in tagList.items track by track(tag)\\\" data-ng-class=\\\"{ selected: tag == tagList.selected }\\\"><ti-tag-item data=\\\"tag\\\"></ti-tag-item></li></ul><input class=\\\"input u-no-margin--top u-no-margin--bottom\\\" autocomplete=\\\"off\\\" data-ng-model=\\\"newTag.text\\\" data-ng-change=\\\"eventHandlers.input.change(newTag.text)\\\" data-ng-keydown=\\\"eventHandlers.input.keydown($event)\\\" data-ng-focus=\\\"eventHandlers.input.focus($event)\\\" data-ng-blur=\\\"eventHandlers.input.blur($event)\\\" data-ng-paste=\\\"eventHandlers.input.paste($event)\\\" data-ng-trim=\\\"false\\\" data-ng-class=\\\"{'invalid-tag': newTag.invalid}\\\" data-ng-disabled=\\\"disabled\\\" ti-bind-attrs=\\\"{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex, spellcheck: options.spellcheck}\\\" ti-autosize=\\\"\\\"></div></div>\"\n  );\n\n  $templateCache.put('ngTagsInput/tag-item.html',\n    \"<span ng-bind=\\\"$getDisplayText()\\\"></span> <a class=\\\"p-icon--close\\\" data-ng-click=\\\"$removeTag()\\\" data-ng-bind=\\\"$$removeTagSymbol\\\">Remove tag</a>\"\n  );\n\n  $templateCache.put('ngTagsInput/auto-complete.html',\n    \"<div class=\\\"autocomplete\\\" data-ng-if=\\\"suggestionList.visible\\\"><ul class=\\\"p-list suggestion-list\\\"><li class=\\\"suggestion-item\\\" data-ng-repeat=\\\"item in suggestionList.items track by track(item)\\\" data-ng-class=\\\"{selected: item == suggestionList.selected}\\\" data-ng-click=\\\"addSuggestionByIndex($index)\\\" data-ng-mouseenter=\\\"suggestionList.select($index)\\\"><ti-autocomplete-match data=\\\"item\\\"></ti-autocomplete-match></li></ul></div>\"\n  );\n\n  $templateCache.put('ngTagsInput/auto-complete-match.html',\n    \"<span data-ng-bind-html=\\\"$highlight($getDisplayText())\\\"></span>\"\n  );\n}]);\n\n}());\n","/*!\n * Angular Virtual Scroll Repeat v1.1.11\n * https://github.com/kamilkp/angular-vs-repeat/\n *\n * Copyright Kamil Pękala\n * http://github.com/kamilkp\n *\n * Released under the MIT License\n * https://opensource.org/licenses/MIT\n *\n * Date: 2018/03/09\n *\n */\n\n(function(window, angular) {\n    'use strict';\n    /* jshint eqnull:true */\n    /* jshint -W038 */\n\n    // DESCRIPTION:\n    // vsRepeat directive stands for Virtual Scroll Repeat. It turns a standard ngRepeated set of elements in a scrollable container\n    // into a component, where the user thinks he has all the elements rendered and all he needs to do is scroll (without any kind of\n    // pagination - which most users loath) and at the same time the browser isn't overloaded by that many elements/angular bindings etc.\n    // The directive renders only so many elements that can fit into current container's clientHeight/clientWidth.\n\n    // LIMITATIONS:\n    // - current version only supports an Array as a right-hand-side object for ngRepeat\n    // - all rendered elements must have the same height/width or the sizes of the elements must be known up front\n\n    // USAGE:\n    // In order to use the vsRepeat directive you need to place a vs-repeat attribute on a direct parent of an element with ng-repeat\n    // example:\n    // <div vs-repeat>\n    //      <div ng-repeat=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // or:\n    // <div vs-repeat>\n    //      <div ng-repeat-start=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    //      <div>\n    //         <!-- something in the middle -->\n    //      </div>\n    //      <div ng-repeat-end>\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // You can also measure the single element's height/width (including all paddings and margins), and then speficy it as a value\n    // of the attribute 'vs-repeat'. This can be used if one wants to override the automatically computed element size.\n    // example:\n    // <div vs-repeat=\"50\"> <!-- the specified element height is 50px -->\n    //      <div ng-repeat=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // IMPORTANT!\n    //\n    // - the vsRepeat directive must be applied to a direct parent of an element with ngRepeat\n    // - the value of vsRepeat attribute is the single element's height/width measured in pixels. If none provided, the directive\n    //      will compute it automatically\n\n    // OPTIONAL PARAMETERS (attributes):\n    // vs-repeat-container=\"selector\" - selector for element containing ng-repeat. (defaults to the current element)\n    // vs-scroll-parent=\"selector\" - selector to the scrollable container. The directive will look for a closest parent matching\n    //                              the given selector (defaults to the current element)\n    // vs-horizontal - stack repeated elements horizontally instead of vertically\n    // vs-offset-before=\"value\" - top/left offset in pixels (defaults to 0)\n    // vs-offset-after=\"value\" - bottom/right offset in pixels (defaults to 0)\n    // vs-excess=\"value\" - an integer number representing the number of elements to be rendered outside of the current container's viewport\n    //                      (defaults to 2)\n    // vs-size - a property name of the items in collection that is a number denoting the element size (in pixels)\n    // vs-autoresize - use this attribute without vs-size and without specifying element's size. The automatically computed element style will\n    //              readjust upon window resize if the size is dependable on the viewport size\n    // vs-scrolled-to-end=\"callback\" - callback will be called when the last item of the list is rendered\n    // vs-scrolled-to-end-offset=\"integer\" - set this number to trigger the scrolledToEnd callback n items before the last gets rendered\n    // vs-scrolled-to-beginning=\"callback\" - callback will be called when the first item of the list is rendered\n    // vs-scrolled-to-beginning-offset=\"integer\" - set this number to trigger the scrolledToBeginning callback n items before the first gets rendered\n\n    // EVENTS:\n    // - 'vsRepeatTrigger' - an event the directive listens for to manually trigger reinitialization\n    // - 'vsRepeatReinitialized' - an event the directive emits upon reinitialization done\n\n    var dde = document.documentElement,\n        matchingFunction = dde.matches ? 'matches' :\n                            dde.matchesSelector ? 'matchesSelector' :\n                            dde.webkitMatches ? 'webkitMatches' :\n                            dde.webkitMatchesSelector ? 'webkitMatchesSelector' :\n                            dde.msMatches ? 'msMatches' :\n                            dde.msMatchesSelector ? 'msMatchesSelector' :\n                            dde.mozMatches ? 'mozMatches' :\n                            dde.mozMatchesSelector ? 'mozMatchesSelector' : null;\n\n    var closestElement = angular.element.prototype.closest || function (selector) {\n        var el = this[0].parentNode;\n        while (el !== document.documentElement && el != null && !el[matchingFunction](selector)) {\n            el = el.parentNode;\n        }\n\n        if (el && el[matchingFunction](selector)) {\n            return angular.element(el);\n        }\n        else {\n            return angular.element();\n        }\n    };\n\n    function getWindowScroll() {\n        if ('pageYOffset' in window) {\n            return {\n                scrollTop: pageYOffset,\n                scrollLeft: pageXOffset\n            };\n        }\n        else {\n            var sx, sy, d = document, r = d.documentElement, b = d.body;\n            sx = r.scrollLeft || b.scrollLeft || 0;\n            sy = r.scrollTop || b.scrollTop || 0;\n            return {\n                scrollTop: sy,\n                scrollLeft: sx\n            };\n        }\n    }\n\n    function getClientSize(element, sizeProp) {\n        if (element === window) {\n            return sizeProp === 'clientWidth' ? window.innerWidth : window.innerHeight;\n        }\n        else {\n            return element[sizeProp];\n        }\n    }\n\n    function getScrollPos(element, scrollProp) {\n        return element === window ? getWindowScroll()[scrollProp] : element[scrollProp];\n    }\n\n    function getScrollOffset(vsElement, scrollElement, isHorizontal) {\n        var vsPos = vsElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];\n        var scrollPos = scrollElement === window ? 0 : scrollElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];\n        var correction = vsPos - scrollPos +\n            (scrollElement === window ? getWindowScroll() : scrollElement)[isHorizontal ? 'scrollLeft' : 'scrollTop'];\n\n        return correction;\n    }\n\n    var vsRepeatModule = angular.module('vs-repeat', []).directive('vsRepeat', ['$compile', '$parse', function($compile, $parse) {\n        return {\n            restrict: 'A',\n            scope: true,\n            compile: function($element, $attrs) {\n                var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element,\n                    ngRepeatChild = repeatContainer.children().eq(0),\n                    ngRepeatExpression,\n                    childCloneHtml = ngRepeatChild[0].outerHTML,\n                    expressionMatches,\n                    lhs,\n                    rhs,\n                    rhsSuffix,\n                    originalNgRepeatAttr,\n                    collectionName = '$vs_collection',\n                    isNgRepeatStart = false,\n                    attributesDictionary = {\n                        'vsRepeat': 'elementSize',\n                        'vsOffsetBefore': 'offsetBefore',\n                        'vsOffsetAfter': 'offsetAfter',\n                        'vsScrolledToEndOffset': 'scrolledToEndOffset',\n                        'vsScrolledToBeginningOffset': 'scrolledToBeginningOffset',\n                        'vsExcess': 'excess',\n                        'vsScrollMargin': 'scrollMargin'\n                    };\n\n                if (ngRepeatChild.attr('ng-repeat')) {\n                    originalNgRepeatAttr = 'ng-repeat';\n                    ngRepeatExpression = ngRepeatChild.attr('ng-repeat');\n                }\n                else if (ngRepeatChild.attr('data-ng-repeat')) {\n                    originalNgRepeatAttr = 'data-ng-repeat';\n                    ngRepeatExpression = ngRepeatChild.attr('data-ng-repeat');\n                }\n                else if (ngRepeatChild.attr('ng-repeat-start')) {\n                    isNgRepeatStart = true;\n                    originalNgRepeatAttr = 'ng-repeat-start';\n                    ngRepeatExpression = ngRepeatChild.attr('ng-repeat-start');\n                }\n                else if (ngRepeatChild.attr('data-ng-repeat-start')) {\n                    isNgRepeatStart = true;\n                    originalNgRepeatAttr = 'data-ng-repeat-start';\n                    ngRepeatExpression = ngRepeatChild.attr('data-ng-repeat-start');\n                }\n                else {\n                    throw new Error('angular-vs-repeat: no ng-repeat directive on a child element');\n                }\n\n                expressionMatches = /^\\s*(\\S+)\\s+in\\s+([\\S\\s]+?)(track\\s+by\\s+\\S+)?$/.exec(ngRepeatExpression);\n                lhs = expressionMatches[1];\n                rhs = expressionMatches[2];\n                rhsSuffix = expressionMatches[3];\n\n                if (isNgRepeatStart) {\n                    var index = 0;\n                    var repeaterElement = repeatContainer.children().eq(0);\n                    while(repeaterElement.attr('ng-repeat-end') == null && repeaterElement.attr('data-ng-repeat-end') == null) {\n                        index++;\n                        repeaterElement = repeatContainer.children().eq(index);\n                        childCloneHtml += repeaterElement[0].outerHTML;\n                    }\n                }\n\n                repeatContainer.empty();\n                return {\n                    pre: function($scope, $element, $attrs) {\n                        var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element,\n                            childClone = angular.element(childCloneHtml),\n                            childTagName = childClone[0].tagName.toLowerCase(),\n                            originalCollection = [],\n                            originalLength,\n                            $$horizontal = typeof $attrs.vsHorizontal !== 'undefined',\n                            $beforeContent = angular.element('<' + childTagName + ' class=\"vs-repeat-before-content\"></' + childTagName + '>'),\n                            $afterContent = angular.element('<' + childTagName + ' class=\"vs-repeat-after-content\"></' + childTagName + '>'),\n                            autoSize = !$attrs.vsRepeat,\n                            sizesPropertyExists = !!$attrs.vsSize || !!$attrs.vsSizeProperty,\n                            $scrollParent = $attrs.vsScrollParent ?\n                                $attrs.vsScrollParent === 'window' ? angular.element(window) :\n                                closestElement.call(repeatContainer, $attrs.vsScrollParent) : repeatContainer,\n                            $$options = 'vsOptions' in $attrs ? $scope.$eval($attrs.vsOptions) : {},\n                            clientSize = $$horizontal ? 'clientWidth' : 'clientHeight',\n                            offsetSize = $$horizontal ? 'offsetWidth' : 'offsetHeight',\n                            scrollPos = $$horizontal ? 'scrollLeft' : 'scrollTop';\n\n                        $scope.totalSize = 0;\n                        if (!('vsSize' in $attrs) && 'vsSizeProperty' in $attrs) {\n                            console.warn('vs-size-property attribute is deprecated. Please use vs-size attribute which also accepts angular expressions.');\n                        }\n\n                        if ($scrollParent.length === 0) {\n                            throw 'Specified scroll parent selector did not match any element';\n                        }\n                        $scope.$scrollParent = $scrollParent;\n\n                        if (sizesPropertyExists) {\n                            $scope.sizesCumulative = [];\n                        }\n\n                        //initial defaults\n                        $scope.elementSize = (+$attrs.vsRepeat) || getClientSize($scrollParent[0], clientSize) || 50;\n                        $scope.offsetBefore = 0;\n                        $scope.offsetAfter = 0;\n                        $scope.scrollMargin = 0;\n                        $scope.excess = 2;\n\n                        if ($$horizontal) {\n                            $beforeContent.css('height', '100%');\n                            $afterContent.css('height', '100%');\n                        }\n                        else {\n                            $beforeContent.css('width', '100%');\n                            $afterContent.css('width', '100%');\n                        }\n\n                        Object.keys(attributesDictionary).forEach(function(key) {\n                            if ($attrs[key]) {\n                                $attrs.$observe(key, function(value) {\n                                    // '+' serves for getting a number from the string as the attributes are always strings\n                                    $scope[attributesDictionary[key]] = +value;\n                                    reinitialize();\n                                });\n                            }\n                        });\n\n\n                        $scope.$watchCollection(rhs, function(coll) {\n                            originalCollection = coll || [];\n                            refresh();\n                        });\n\n                        function refresh() {\n                            if (!originalCollection || originalCollection.length < 1) {\n                                $scope[collectionName] = [];\n                                originalLength = 0;\n                                $scope.sizesCumulative = [0];\n                            }\n                            else {\n                                originalLength = originalCollection.length;\n                                if (sizesPropertyExists) {\n                                    $scope.sizes = originalCollection.map(function(item) {\n                                        var s = $scope.$new(false);\n                                        angular.extend(s, item);\n                                        s[lhs] = item;\n                                        var size = ($attrs.vsSize || $attrs.vsSizeProperty) ?\n                                                        s.$eval($attrs.vsSize || $attrs.vsSizeProperty) :\n                                                        $scope.elementSize;\n                                        s.$destroy();\n                                        return size;\n                                    });\n                                    var sum = 0;\n                                    $scope.sizesCumulative = $scope.sizes.map(function(size) {\n                                        var res = sum;\n                                        sum += size;\n                                        return res;\n                                    });\n                                    $scope.sizesCumulative.push(sum);\n                                }\n                                else {\n                                    setAutoSize();\n                                }\n                            }\n\n                            reinitialize();\n                        }\n\n                        function setAutoSize() {\n                            if (autoSize) {\n                                $scope.$$postDigest(function() {\n                                    if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) { // element is visible\n                                        var children = repeatContainer.children(),\n                                            i = 0,\n                                            gotSomething = false,\n                                            insideStartEndSequence = false;\n\n                                        while (i < children.length) {\n                                            if (children[i].attributes[originalNgRepeatAttr] != null || insideStartEndSequence) {\n                                                if (!gotSomething) {\n                                                    $scope.elementSize = 0;\n                                                }\n\n                                                gotSomething = true;\n                                                if (children[i][offsetSize]) {\n                                                    $scope.elementSize += children[i][offsetSize];\n                                                }\n\n                                                if (isNgRepeatStart) {\n                                                    if (children[i].attributes['ng-repeat-end'] != null || children[i].attributes['data-ng-repeat-end'] != null) {\n                                                        break;\n                                                    }\n                                                    else {\n                                                        insideStartEndSequence = true;\n                                                    }\n                                                }\n                                                else {\n                                                    break;\n                                                }\n                                            }\n                                            i++;\n                                        }\n\n                                        if (gotSomething) {\n                                            reinitialize();\n                                            autoSize = false;\n                                            if ($scope.$root && !$scope.$root.$$phase) {\n                                                $scope.$apply();\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        var dereg = $scope.$watch(function() {\n                                            if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) {\n                                                dereg();\n                                                setAutoSize();\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                        }\n\n                        function getLayoutProp() {\n                            var layoutPropPrefix = childTagName === 'tr' ? '' : 'min-';\n                            var layoutProp = $$horizontal ? layoutPropPrefix + 'width' : layoutPropPrefix + 'height';\n                            return layoutProp;\n                        }\n\n                        childClone.eq(0).attr(originalNgRepeatAttr, lhs + ' in ' + collectionName + (rhsSuffix ? ' ' + rhsSuffix : ''));\n                        childClone.addClass('vs-repeat-repeated-element');\n\n                        repeatContainer.append($beforeContent);\n                        repeatContainer.append(childClone);\n                        $compile(childClone)($scope);\n                        repeatContainer.append($afterContent);\n\n                        $scope.startIndex = 0;\n                        $scope.endIndex = 0;\n\n                        function scrollHandler() {\n                            if (updateInnerCollection()) {\n                                $scope.$digest();\n\n                                var expectedSize = sizesPropertyExists ?\n                                                        $scope.sizesCumulative[originalLength] :\n                                                        $scope.elementSize * originalLength;\n\n                                if (expectedSize !== $element[0].clientHeight) {\n                                    console.warn('vsRepeat: size mismatch. Expected size ' + expectedSize + 'px whereas actual size is ' + $element[0].clientHeight + 'px. Fix vsSize on element:', $element[0]);\n                                }\n                            }\n                        }\n\n                        $scrollParent.on('scroll', scrollHandler);\n\n                        function onWindowResize() {\n                            if (typeof $attrs.vsAutoresize !== 'undefined') {\n                                autoSize = true;\n                                setAutoSize();\n                                if ($scope.$root && !$scope.$root.$$phase) {\n                                    $scope.$apply();\n                                }\n                            }\n                            if (updateInnerCollection()) {\n                                $scope.$apply();\n                            }\n                        }\n\n                        angular.element(window).on('resize', onWindowResize);\n                        $scope.$on('$destroy', function() {\n                            angular.element(window).off('resize', onWindowResize);\n                            $scrollParent.off('scroll', scrollHandler);\n                        });\n\n                        $scope.$on('vsRepeatTrigger', refresh);\n\n                        $scope.$on('vsRepeatResize', function() {\n                            autoSize = true;\n                            setAutoSize();\n                        });\n\n                        var _prevStartIndex,\n                            _prevEndIndex,\n                            _minStartIndex,\n                            _maxEndIndex;\n\n                        $scope.$on('vsRenderAll', function() {//e , quantum) {\n                            if($$options.latch) {\n                                setTimeout(function() {\n                                    // var __endIndex = Math.min($scope.endIndex + (quantum || 1), originalLength);\n                                    var __endIndex = originalLength;\n                                    _maxEndIndex = Math.max(__endIndex, _maxEndIndex);\n                                    $scope.endIndex = $$options.latch ? _maxEndIndex : __endIndex;\n                                    $scope[collectionName] = originalCollection.slice($scope.startIndex, $scope.endIndex);\n                                    _prevEndIndex = $scope.endIndex;\n\n                                    $scope.$$postDigest(function() {\n                                        $beforeContent.css(getLayoutProp(), 0);\n                                        $afterContent.css(getLayoutProp(), 0);\n                                    });\n\n                                    $scope.$apply(function() {\n                                        $scope.$emit('vsRenderAllDone');\n                                    });\n                                });\n                            }\n                        });\n\n                        function reinitialize() {\n                            _prevStartIndex = void 0;\n                            _prevEndIndex = void 0;\n                            _minStartIndex = originalLength;\n                            _maxEndIndex = 0;\n                            updateTotalSize(sizesPropertyExists ?\n                                                $scope.sizesCumulative[originalLength] :\n                                                $scope.elementSize * originalLength\n                                            );\n                            updateInnerCollection();\n\n                            $scope.$emit('vsRepeatReinitialized', $scope.startIndex, $scope.endIndex);\n                        }\n\n                        function updateTotalSize(size) {\n                            $scope.totalSize = $scope.offsetBefore + size + $scope.offsetAfter;\n                        }\n\n                        var _prevClientSize;\n                        function reinitOnClientHeightChange() {\n                            var ch = getClientSize($scrollParent[0], clientSize);\n                            if (ch !== _prevClientSize) {\n                                reinitialize();\n                                if ($scope.$root && !$scope.$root.$$phase) {\n                                    $scope.$apply();\n                                }\n                            }\n                            _prevClientSize = ch;\n                        }\n\n                        $scope.$watch(function() {\n                            if (typeof window.requestAnimationFrame === 'function') {\n                                window.requestAnimationFrame(reinitOnClientHeightChange);\n                            }\n                            else {\n                                reinitOnClientHeightChange();\n                            }\n                        });\n\n                        function updateInnerCollection() {\n                            var $scrollPosition = getScrollPos($scrollParent[0], scrollPos);\n                            var $clientSize = getClientSize($scrollParent[0], clientSize);\n\n                            var scrollOffset = repeatContainer[0] === $scrollParent[0] ? 0 : getScrollOffset(\n                                                    repeatContainer[0],\n                                                    $scrollParent[0],\n                                                    $$horizontal\n                                                );\n\n                            var __startIndex = $scope.startIndex;\n                            var __endIndex = $scope.endIndex;\n\n                            if (sizesPropertyExists) {\n                                __startIndex = 0;\n                                while ($scope.sizesCumulative[__startIndex] < $scrollPosition - $scope.offsetBefore - scrollOffset - $scope.scrollMargin) {\n                                    __startIndex++;\n                                }\n                                if (__startIndex > 0) { __startIndex--; }\n\n                                // Adjust the start index according to the excess\n                                __startIndex = Math.max(\n                                    Math.floor(__startIndex - $scope.excess / 2),\n                                    0\n                                );\n\n                                __endIndex = __startIndex;\n                                while ($scope.sizesCumulative[__endIndex] < $scrollPosition - $scope.offsetBefore - scrollOffset + $scope.scrollMargin + $clientSize) {\n                                    __endIndex++;\n                                }\n\n                                // Adjust the end index according to the excess\n                                __endIndex = Math.min(\n                                    Math.ceil(__endIndex + $scope.excess / 2),\n                                    originalLength\n                                );\n                            }\n                            else {\n                                __startIndex = Math.max(\n                                    Math.floor(\n                                        ($scrollPosition - $scope.offsetBefore - scrollOffset) / $scope.elementSize\n                                    ) - $scope.excess / 2,\n                                    0\n                                );\n\n                                __endIndex = Math.min(\n                                    __startIndex + Math.ceil(\n                                        $clientSize / $scope.elementSize\n                                    ) + $scope.excess,\n                                    originalLength\n                                );\n                            }\n\n                            _minStartIndex = Math.min(__startIndex, _minStartIndex);\n                            _maxEndIndex = Math.max(__endIndex, _maxEndIndex);\n\n                            $scope.startIndex = $$options.latch ? _minStartIndex : __startIndex;\n                            $scope.endIndex = $$options.latch ? _maxEndIndex : __endIndex;\n\n                            // Move to the end of the collection if we are now past it\n                            if (_maxEndIndex < $scope.startIndex)\n                                $scope.startIndex = _maxEndIndex;\n\n                            var digestRequired = false;\n                            if (_prevStartIndex == null) {\n                                digestRequired = true;\n                            }\n                            else if (_prevEndIndex == null) {\n                                digestRequired = true;\n                            }\n\n                            if (!digestRequired) {\n                                if ($$options.hunked) {\n                                    if (Math.abs($scope.startIndex - _prevStartIndex) >= $scope.excess / 2 ||\n                                        ($scope.startIndex === 0 && _prevStartIndex !== 0)) {\n                                        digestRequired = true;\n                                    }\n                                    else if (Math.abs($scope.endIndex - _prevEndIndex) >= $scope.excess / 2 ||\n                                        ($scope.endIndex === originalLength && _prevEndIndex !== originalLength)) {\n                                        digestRequired = true;\n                                    }\n                                }\n                                else {\n                                    digestRequired = $scope.startIndex !== _prevStartIndex ||\n                                                        $scope.endIndex !== _prevEndIndex;\n                                }\n                            }\n\n                            if (digestRequired) {\n                                $scope[collectionName] = originalCollection.slice($scope.startIndex, $scope.endIndex);\n\n                                // Emit the event\n                                $scope.$emit('vsRepeatInnerCollectionUpdated', $scope.startIndex, $scope.endIndex, _prevStartIndex, _prevEndIndex);\n                                var triggerIndex;\n                                if ($attrs.vsScrolledToEnd) {\n                                    triggerIndex = originalCollection.length - ($scope.scrolledToEndOffset || 0);\n                                    if (($scope.endIndex >= triggerIndex && _prevEndIndex < triggerIndex) || (originalCollection.length && $scope.endIndex === originalCollection.length)) {\n                                        $scope.$eval($attrs.vsScrolledToEnd);\n                                    }\n                                }\n                                if ($attrs.vsScrolledToBeginning) {\n                                    triggerIndex = $scope.scrolledToBeginningOffset || 0;\n                                    if (($scope.startIndex <= triggerIndex && _prevStartIndex > $scope.startIndex)) {\n                                        $scope.$eval($attrs.vsScrolledToBeginning);\n                                    }\n                                }\n\n                                _prevStartIndex = $scope.startIndex;\n                                _prevEndIndex = $scope.endIndex;\n\n                                var offsetCalculationString = sizesPropertyExists ?\n                                    '(sizesCumulative[$index + startIndex] + offsetBefore)' :\n                                    '(($index + startIndex) * elementSize + offsetBefore)';\n\n                                var parsed = $parse(offsetCalculationString);\n                                var o1 = parsed($scope, {$index: 0});\n                                var o2 = parsed($scope, {$index: $scope[collectionName].length});\n                                var total = $scope.totalSize;\n\n                                $beforeContent.css(getLayoutProp(), o1 + 'px');\n                                $afterContent.css(getLayoutProp(), (total - o2) + 'px');\n                            }\n\n                            return digestRequired;\n                        }\n                    }\n                };\n            }\n        };\n    }]);\n\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = vsRepeatModule.name;\n    }\n})(window, window.angular);\n"],"sourceRoot":""}
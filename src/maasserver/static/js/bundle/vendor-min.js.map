{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/maasserver/static/js/angular/3rdparty/vs-repeat.js","webpack:///./src/maasserver/static/js/angular/3rdparty/ng-tags-input.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","window","angular","dde","document","documentElement","matchingFunction","matches","matchesSelector","webkitMatches","webkitMatchesSelector","msMatches","msMatchesSelector","mozMatches","mozMatchesSelector","closestElement","element","closest","selector","el","this","parentNode","getWindowScroll","scrollTop","pageYOffset","scrollLeft","pageXOffset","sx","b","body","getClientSize","sizeProp","innerWidth","innerHeight","vsRepeatModule","directive","$compile","$parse","restrict","scope","compile","$element","$attrs","ngRepeatExpression","expressionMatches","lhs","rhs","rhsSuffix","originalNgRepeatAttr","repeatContainer","isDefined","vsRepeatContainer","querySelector","ngRepeatChild","children","eq","childCloneHtml","outerHTML","collectionName","isNgRepeatStart","attributesDictionary","vsRepeat","vsOffsetBefore","vsOffsetAfter","vsScrolledToEndOffset","vsScrolledToBeginningOffset","vsExcess","vsScrollMargin","attr","Error","exec","index","repeaterElement","empty","pre","$scope","originalLength","_prevStartIndex","_prevEndIndex","_minStartIndex","_maxEndIndex","_prevClientSize","childClone","childTagName","tagName","toLowerCase","originalCollection","$$horizontal","vsHorizontal","$beforeContent","$afterContent","autoSize","sizesPropertyExists","vsSize","vsSizeProperty","$scrollParent","vsScrollParent","$$options","$eval","vsOptions","clientSize","offsetSize","scrollPos","totalSize","console","warn","length","refresh","sizesCumulative","sizes","map","item","$new","extend","size","elementSize","$destroy","sum","res","push","setAutoSize","reinitialize","$$postDigest","offsetHeight","offsetWidth","gotSomething","insideStartEndSequence","attributes","$root","$$phase","$apply","dereg","$watch","getLayoutProp","layoutPropPrefix","scrollHandler","updateInnerCollection","$digest","expectedSize","clientHeight","onWindowResize","vsAutoresize","offsetBefore","offsetAfter","$emit","startIndex","endIndex","reinitOnClientHeightChange","ch","scrollProp","vsElement","scrollElement","isHorizontal","$scrollPosition","$clientSize","scrollOffset","getBoundingClientRect","__startIndex","__endIndex","scrollMargin","Math","max","floor","excess","min","ceil","latch","digestRequired","hunked","abs","triggerIndex","slice","vsScrolledToEnd","scrolledToEndOffset","vsScrolledToBeginning","scrolledToBeginningOffset","parsed","o1","$index","o2","total","css","keys","forEach","key","$observe","$watchCollection","coll","addClass","append","on","$on","off","setTimeout","requestAnimationFrame","KEYS","SUPPORTED_INPUT_TYPES","tagsInput","$timeout","$document","$window","tagsInputConfig","tiUtil","validateType","type","indexOf","require","tags","onTagAdding","onTagAdded","onInvalidTag","onTagRemoving","onTagRemoved","replace","transclude","templateUrl","controller","events","simplePubSub","load","template","String","placeholder","tabindex","Number","removeTagSymbol","fromCharCode","replaceSpacesWithDashes","Boolean","minLength","maxLength","addOnEnter","addOnSpace","addOnComma","addOnBlur","addOnPaste","pasteSplitPattern","RegExp","allowedTagsPattern","enableEditingLastTag","minTags","maxTags","displayProperty","keyProperty","allowLeftoverText","addFromAutocompleteOnly","spellcheck","tagList","options","getTagText","setTagText","tagIsValid","self","tag","safeToString","text","tagText","test","findInObjectArray","items","$tag","addText","add","trigger","remove","splice","clearSelection","select","selected","selectPrior","selectNext","removeSelected","handleUndefinedResult","registerAutocomplete","find","addTag","focusInput","getTags","getCurrentTagText","newTag","getOptions","handler","registerTagItem","removeTag","disabled","link","attrs","ngModelCtrl","setElementValidity","hotkeys","input","validationOptions","$setValidity","hasFocus","$isEmpty","invalid","setText","track","makeObjectArray","eventHandlers","change","keydown","$event","focus","blur","activeElement","prop","lostFocusToBrowserWindow","lostFocusToChildElement","contains","paste","getTextData","clipboardData","originalEvent","getData","host","click","$setViewValue","e","triggerHandler","event","shouldAdd","shouldRemove","shouldSelect","shouldEditLastTag","keyCode","addKeys","shiftKey","altKey","ctrlKey","metaKey","preventDefault","split","data","tagsInputCtrl","$$template","$$removeTagSymbol","$getDisplayText","$removeTag","$sce","$q","source","debounceDelay","highlightMatchedText","maxResultsToShow","loadOnDownArrow","loadOnEmpty","loadOnFocus","selectFirstMatch","suggestionList","loadFn","getDifference","lastPromise","getTagId","array1","array2","filter","a","defaultComparer","reset","visible","query","show","debounce","promise","when","$query","then","getCurrentTag","$parent","registerAutocompleteMatch","getQuery","shouldLoadSuggestions","addSuggestionByIndex","addSuggestion","added","copy","handled","stopImmediatePropagation","root","parent","elementTop","elementHeight","parentHeight","parentScrollTop","scrollToElement","autoCompleteCtrl","autoComplete","$highlight","safeHighlight","trustAsHtml","ctrl","transcludeFn","clone","span","resize","threshold","getTextAutosizeThreshold","originalValue","width","isString","$parsers","unshift","$formatters","$modelValue","tiBindAttrs","$set","provider","globalDefaults","interpolationStatus","autosizeThreshold","setDefaults","defaults","setActiveInterpolation","setTextAutosizeThreshold","$get","$interpolate","converters","parseInt","defaultValidator","localDefault","validator","converter","getDefault","updateValue","globalValue","newValue","factory","fn","delay","timeoutId","args","arguments","cancel","apply","array","isObject","obj","comparer","some","str","encodeHTML","expression","escapeRegexChars","match","isUndefined","toString","trim","valueIfUndefined","result","names","every","run","$templateCache","put"],"mappings":"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","file":"vendor-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 626);\n","/*!\n * Angular Virtual Scroll Repeat v1.1.11\n * https://github.com/kamilkp/angular-vs-repeat/\n *\n * Copyright Kamil Pękala\n * http://github.com/kamilkp\n *\n * Released under the MIT License\n * https://opensource.org/licenses/MIT\n *\n * Date: 2018/03/09\n *\n */\n\n(function(window, angular) {\n    'use strict';\n    /* jshint eqnull:true */\n    /* jshint -W038 */\n\n    // DESCRIPTION:\n    // vsRepeat directive stands for Virtual Scroll Repeat. It turns a standard ngRepeated set of elements in a scrollable container\n    // into a component, where the user thinks he has all the elements rendered and all he needs to do is scroll (without any kind of\n    // pagination - which most users loath) and at the same time the browser isn't overloaded by that many elements/angular bindings etc.\n    // The directive renders only so many elements that can fit into current container's clientHeight/clientWidth.\n\n    // LIMITATIONS:\n    // - current version only supports an Array as a right-hand-side object for ngRepeat\n    // - all rendered elements must have the same height/width or the sizes of the elements must be known up front\n\n    // USAGE:\n    // In order to use the vsRepeat directive you need to place a vs-repeat attribute on a direct parent of an element with ng-repeat\n    // example:\n    // <div vs-repeat>\n    //      <div ng-repeat=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // or:\n    // <div vs-repeat>\n    //      <div ng-repeat-start=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    //      <div>\n    //         <!-- something in the middle -->\n    //      </div>\n    //      <div ng-repeat-end>\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // You can also measure the single element's height/width (including all paddings and margins), and then speficy it as a value\n    // of the attribute 'vs-repeat'. This can be used if one wants to override the automatically computed element size.\n    // example:\n    // <div vs-repeat=\"50\"> <!-- the specified element height is 50px -->\n    //      <div ng-repeat=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // IMPORTANT!\n    //\n    // - the vsRepeat directive must be applied to a direct parent of an element with ngRepeat\n    // - the value of vsRepeat attribute is the single element's height/width measured in pixels. If none provided, the directive\n    //      will compute it automatically\n\n    // OPTIONAL PARAMETERS (attributes):\n    // vs-repeat-container=\"selector\" - selector for element containing ng-repeat. (defaults to the current element)\n    // vs-scroll-parent=\"selector\" - selector to the scrollable container. The directive will look for a closest parent matching\n    //                              the given selector (defaults to the current element)\n    // vs-horizontal - stack repeated elements horizontally instead of vertically\n    // vs-offset-before=\"value\" - top/left offset in pixels (defaults to 0)\n    // vs-offset-after=\"value\" - bottom/right offset in pixels (defaults to 0)\n    // vs-excess=\"value\" - an integer number representing the number of elements to be rendered outside of the current container's viewport\n    //                      (defaults to 2)\n    // vs-size - a property name of the items in collection that is a number denoting the element size (in pixels)\n    // vs-autoresize - use this attribute without vs-size and without specifying element's size. The automatically computed element style will\n    //              readjust upon window resize if the size is dependable on the viewport size\n    // vs-scrolled-to-end=\"callback\" - callback will be called when the last item of the list is rendered\n    // vs-scrolled-to-end-offset=\"integer\" - set this number to trigger the scrolledToEnd callback n items before the last gets rendered\n    // vs-scrolled-to-beginning=\"callback\" - callback will be called when the first item of the list is rendered\n    // vs-scrolled-to-beginning-offset=\"integer\" - set this number to trigger the scrolledToBeginning callback n items before the first gets rendered\n\n    // EVENTS:\n    // - 'vsRepeatTrigger' - an event the directive listens for to manually trigger reinitialization\n    // - 'vsRepeatReinitialized' - an event the directive emits upon reinitialization done\n\n    var dde = document.documentElement,\n        matchingFunction = dde.matches ? 'matches' :\n                            dde.matchesSelector ? 'matchesSelector' :\n                            dde.webkitMatches ? 'webkitMatches' :\n                            dde.webkitMatchesSelector ? 'webkitMatchesSelector' :\n                            dde.msMatches ? 'msMatches' :\n                            dde.msMatchesSelector ? 'msMatchesSelector' :\n                            dde.mozMatches ? 'mozMatches' :\n                            dde.mozMatchesSelector ? 'mozMatchesSelector' : null;\n\n    var closestElement = angular.element.prototype.closest || function (selector) {\n        var el = this[0].parentNode;\n        while (el !== document.documentElement && el != null && !el[matchingFunction](selector)) {\n            el = el.parentNode;\n        }\n\n        if (el && el[matchingFunction](selector)) {\n            return angular.element(el);\n        }\n        else {\n            return angular.element();\n        }\n    };\n\n    function getWindowScroll() {\n        if ('pageYOffset' in window) {\n            return {\n                scrollTop: pageYOffset,\n                scrollLeft: pageXOffset\n            };\n        }\n        else {\n            var sx, sy, d = document, r = d.documentElement, b = d.body;\n            sx = r.scrollLeft || b.scrollLeft || 0;\n            sy = r.scrollTop || b.scrollTop || 0;\n            return {\n                scrollTop: sy,\n                scrollLeft: sx\n            };\n        }\n    }\n\n    function getClientSize(element, sizeProp) {\n        if (element === window) {\n            return sizeProp === 'clientWidth' ? window.innerWidth : window.innerHeight;\n        }\n        else {\n            return element[sizeProp];\n        }\n    }\n\n    function getScrollPos(element, scrollProp) {\n        return element === window ? getWindowScroll()[scrollProp] : element[scrollProp];\n    }\n\n    function getScrollOffset(vsElement, scrollElement, isHorizontal) {\n        var vsPos = vsElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];\n        var scrollPos = scrollElement === window ? 0 : scrollElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];\n        var correction = vsPos - scrollPos +\n            (scrollElement === window ? getWindowScroll() : scrollElement)[isHorizontal ? 'scrollLeft' : 'scrollTop'];\n\n        return correction;\n    }\n\n    var vsRepeatModule = angular.module('vs-repeat', []).directive('vsRepeat', ['$compile', '$parse', function($compile, $parse) {\n        return {\n            restrict: 'A',\n            scope: true,\n            compile: function($element, $attrs) {\n                var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element,\n                    ngRepeatChild = repeatContainer.children().eq(0),\n                    ngRepeatExpression,\n                    childCloneHtml = ngRepeatChild[0].outerHTML,\n                    expressionMatches,\n                    lhs,\n                    rhs,\n                    rhsSuffix,\n                    originalNgRepeatAttr,\n                    collectionName = '$vs_collection',\n                    isNgRepeatStart = false,\n                    attributesDictionary = {\n                        'vsRepeat': 'elementSize',\n                        'vsOffsetBefore': 'offsetBefore',\n                        'vsOffsetAfter': 'offsetAfter',\n                        'vsScrolledToEndOffset': 'scrolledToEndOffset',\n                        'vsScrolledToBeginningOffset': 'scrolledToBeginningOffset',\n                        'vsExcess': 'excess',\n                        'vsScrollMargin': 'scrollMargin'\n                    };\n\n                if (ngRepeatChild.attr('ng-repeat')) {\n                    originalNgRepeatAttr = 'ng-repeat';\n                    ngRepeatExpression = ngRepeatChild.attr('ng-repeat');\n                }\n                else if (ngRepeatChild.attr('data-ng-repeat')) {\n                    originalNgRepeatAttr = 'data-ng-repeat';\n                    ngRepeatExpression = ngRepeatChild.attr('data-ng-repeat');\n                }\n                else if (ngRepeatChild.attr('ng-repeat-start')) {\n                    isNgRepeatStart = true;\n                    originalNgRepeatAttr = 'ng-repeat-start';\n                    ngRepeatExpression = ngRepeatChild.attr('ng-repeat-start');\n                }\n                else if (ngRepeatChild.attr('data-ng-repeat-start')) {\n                    isNgRepeatStart = true;\n                    originalNgRepeatAttr = 'data-ng-repeat-start';\n                    ngRepeatExpression = ngRepeatChild.attr('data-ng-repeat-start');\n                }\n                else {\n                    throw new Error('angular-vs-repeat: no ng-repeat directive on a child element');\n                }\n\n                expressionMatches = /^\\s*(\\S+)\\s+in\\s+([\\S\\s]+?)(track\\s+by\\s+\\S+)?$/.exec(ngRepeatExpression);\n                lhs = expressionMatches[1];\n                rhs = expressionMatches[2];\n                rhsSuffix = expressionMatches[3];\n\n                if (isNgRepeatStart) {\n                    var index = 0;\n                    var repeaterElement = repeatContainer.children().eq(0);\n                    while(repeaterElement.attr('ng-repeat-end') == null && repeaterElement.attr('data-ng-repeat-end') == null) {\n                        index++;\n                        repeaterElement = repeatContainer.children().eq(index);\n                        childCloneHtml += repeaterElement[0].outerHTML;\n                    }\n                }\n\n                repeatContainer.empty();\n                return {\n                    pre: function($scope, $element, $attrs) {\n                        var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element,\n                            childClone = angular.element(childCloneHtml),\n                            childTagName = childClone[0].tagName.toLowerCase(),\n                            originalCollection = [],\n                            originalLength,\n                            $$horizontal = typeof $attrs.vsHorizontal !== 'undefined',\n                            $beforeContent = angular.element('<' + childTagName + ' class=\"vs-repeat-before-content\"></' + childTagName + '>'),\n                            $afterContent = angular.element('<' + childTagName + ' class=\"vs-repeat-after-content\"></' + childTagName + '>'),\n                            autoSize = !$attrs.vsRepeat,\n                            sizesPropertyExists = !!$attrs.vsSize || !!$attrs.vsSizeProperty,\n                            $scrollParent = $attrs.vsScrollParent ?\n                                $attrs.vsScrollParent === 'window' ? angular.element(window) :\n                                closestElement.call(repeatContainer, $attrs.vsScrollParent) : repeatContainer,\n                            $$options = 'vsOptions' in $attrs ? $scope.$eval($attrs.vsOptions) : {},\n                            clientSize = $$horizontal ? 'clientWidth' : 'clientHeight',\n                            offsetSize = $$horizontal ? 'offsetWidth' : 'offsetHeight',\n                            scrollPos = $$horizontal ? 'scrollLeft' : 'scrollTop';\n\n                        $scope.totalSize = 0;\n                        if (!('vsSize' in $attrs) && 'vsSizeProperty' in $attrs) {\n                            console.warn('vs-size-property attribute is deprecated. Please use vs-size attribute which also accepts angular expressions.');\n                        }\n\n                        if ($scrollParent.length === 0) {\n                            throw 'Specified scroll parent selector did not match any element';\n                        }\n                        $scope.$scrollParent = $scrollParent;\n\n                        if (sizesPropertyExists) {\n                            $scope.sizesCumulative = [];\n                        }\n\n                        //initial defaults\n                        $scope.elementSize = (+$attrs.vsRepeat) || getClientSize($scrollParent[0], clientSize) || 50;\n                        $scope.offsetBefore = 0;\n                        $scope.offsetAfter = 0;\n                        $scope.scrollMargin = 0;\n                        $scope.excess = 2;\n\n                        if ($$horizontal) {\n                            $beforeContent.css('height', '100%');\n                            $afterContent.css('height', '100%');\n                        }\n                        else {\n                            $beforeContent.css('width', '100%');\n                            $afterContent.css('width', '100%');\n                        }\n\n                        Object.keys(attributesDictionary).forEach(function(key) {\n                            if ($attrs[key]) {\n                                $attrs.$observe(key, function(value) {\n                                    // '+' serves for getting a number from the string as the attributes are always strings\n                                    $scope[attributesDictionary[key]] = +value;\n                                    reinitialize();\n                                });\n                            }\n                        });\n\n\n                        $scope.$watchCollection(rhs, function(coll) {\n                            originalCollection = coll || [];\n                            refresh();\n                        });\n\n                        function refresh() {\n                            if (!originalCollection || originalCollection.length < 1) {\n                                $scope[collectionName] = [];\n                                originalLength = 0;\n                                $scope.sizesCumulative = [0];\n                            }\n                            else {\n                                originalLength = originalCollection.length;\n                                if (sizesPropertyExists) {\n                                    $scope.sizes = originalCollection.map(function(item) {\n                                        var s = $scope.$new(false);\n                                        angular.extend(s, item);\n                                        s[lhs] = item;\n                                        var size = ($attrs.vsSize || $attrs.vsSizeProperty) ?\n                                                        s.$eval($attrs.vsSize || $attrs.vsSizeProperty) :\n                                                        $scope.elementSize;\n                                        s.$destroy();\n                                        return size;\n                                    });\n                                    var sum = 0;\n                                    $scope.sizesCumulative = $scope.sizes.map(function(size) {\n                                        var res = sum;\n                                        sum += size;\n                                        return res;\n                                    });\n                                    $scope.sizesCumulative.push(sum);\n                                }\n                                else {\n                                    setAutoSize();\n                                }\n                            }\n\n                            reinitialize();\n                        }\n\n                        function setAutoSize() {\n                            if (autoSize) {\n                                $scope.$$postDigest(function() {\n                                    if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) { // element is visible\n                                        var children = repeatContainer.children(),\n                                            i = 0,\n                                            gotSomething = false,\n                                            insideStartEndSequence = false;\n\n                                        while (i < children.length) {\n                                            if (children[i].attributes[originalNgRepeatAttr] != null || insideStartEndSequence) {\n                                                if (!gotSomething) {\n                                                    $scope.elementSize = 0;\n                                                }\n\n                                                gotSomething = true;\n                                                if (children[i][offsetSize]) {\n                                                    $scope.elementSize += children[i][offsetSize];\n                                                }\n\n                                                if (isNgRepeatStart) {\n                                                    if (children[i].attributes['ng-repeat-end'] != null || children[i].attributes['data-ng-repeat-end'] != null) {\n                                                        break;\n                                                    }\n                                                    else {\n                                                        insideStartEndSequence = true;\n                                                    }\n                                                }\n                                                else {\n                                                    break;\n                                                }\n                                            }\n                                            i++;\n                                        }\n\n                                        if (gotSomething) {\n                                            reinitialize();\n                                            autoSize = false;\n                                            if ($scope.$root && !$scope.$root.$$phase) {\n                                                $scope.$apply();\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        var dereg = $scope.$watch(function() {\n                                            if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) {\n                                                dereg();\n                                                setAutoSize();\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                        }\n\n                        function getLayoutProp() {\n                            var layoutPropPrefix = childTagName === 'tr' ? '' : 'min-';\n                            var layoutProp = $$horizontal ? layoutPropPrefix + 'width' : layoutPropPrefix + 'height';\n                            return layoutProp;\n                        }\n\n                        childClone.eq(0).attr(originalNgRepeatAttr, lhs + ' in ' + collectionName + (rhsSuffix ? ' ' + rhsSuffix : ''));\n                        childClone.addClass('vs-repeat-repeated-element');\n\n                        repeatContainer.append($beforeContent);\n                        repeatContainer.append(childClone);\n                        $compile(childClone)($scope);\n                        repeatContainer.append($afterContent);\n\n                        $scope.startIndex = 0;\n                        $scope.endIndex = 0;\n\n                        function scrollHandler() {\n                            if (updateInnerCollection()) {\n                                $scope.$digest();\n\n                                var expectedSize = sizesPropertyExists ?\n                                                        $scope.sizesCumulative[originalLength] :\n                                                        $scope.elementSize * originalLength;\n\n                                if (expectedSize !== $element[0].clientHeight) {\n                                    console.warn('vsRepeat: size mismatch. Expected size ' + expectedSize + 'px whereas actual size is ' + $element[0].clientHeight + 'px. Fix vsSize on element:', $element[0]);\n                                }\n                            }\n                        }\n\n                        $scrollParent.on('scroll', scrollHandler);\n\n                        function onWindowResize() {\n                            if (typeof $attrs.vsAutoresize !== 'undefined') {\n                                autoSize = true;\n                                setAutoSize();\n                                if ($scope.$root && !$scope.$root.$$phase) {\n                                    $scope.$apply();\n                                }\n                            }\n                            if (updateInnerCollection()) {\n                                $scope.$apply();\n                            }\n                        }\n\n                        angular.element(window).on('resize', onWindowResize);\n                        $scope.$on('$destroy', function() {\n                            angular.element(window).off('resize', onWindowResize);\n                            $scrollParent.off('scroll', scrollHandler);\n                        });\n\n                        $scope.$on('vsRepeatTrigger', refresh);\n\n                        $scope.$on('vsRepeatResize', function() {\n                            autoSize = true;\n                            setAutoSize();\n                        });\n\n                        var _prevStartIndex,\n                            _prevEndIndex,\n                            _minStartIndex,\n                            _maxEndIndex;\n\n                        $scope.$on('vsRenderAll', function() {//e , quantum) {\n                            if($$options.latch) {\n                                setTimeout(function() {\n                                    // var __endIndex = Math.min($scope.endIndex + (quantum || 1), originalLength);\n                                    var __endIndex = originalLength;\n                                    _maxEndIndex = Math.max(__endIndex, _maxEndIndex);\n                                    $scope.endIndex = $$options.latch ? _maxEndIndex : __endIndex;\n                                    $scope[collectionName] = originalCollection.slice($scope.startIndex, $scope.endIndex);\n                                    _prevEndIndex = $scope.endIndex;\n\n                                    $scope.$$postDigest(function() {\n                                        $beforeContent.css(getLayoutProp(), 0);\n                                        $afterContent.css(getLayoutProp(), 0);\n                                    });\n\n                                    $scope.$apply(function() {\n                                        $scope.$emit('vsRenderAllDone');\n                                    });\n                                });\n                            }\n                        });\n\n                        function reinitialize() {\n                            _prevStartIndex = void 0;\n                            _prevEndIndex = void 0;\n                            _minStartIndex = originalLength;\n                            _maxEndIndex = 0;\n                            updateTotalSize(sizesPropertyExists ?\n                                                $scope.sizesCumulative[originalLength] :\n                                                $scope.elementSize * originalLength\n                                            );\n                            updateInnerCollection();\n\n                            $scope.$emit('vsRepeatReinitialized', $scope.startIndex, $scope.endIndex);\n                        }\n\n                        function updateTotalSize(size) {\n                            $scope.totalSize = $scope.offsetBefore + size + $scope.offsetAfter;\n                        }\n\n                        var _prevClientSize;\n                        function reinitOnClientHeightChange() {\n                            var ch = getClientSize($scrollParent[0], clientSize);\n                            if (ch !== _prevClientSize) {\n                                reinitialize();\n                                if ($scope.$root && !$scope.$root.$$phase) {\n                                    $scope.$apply();\n                                }\n                            }\n                            _prevClientSize = ch;\n                        }\n\n                        $scope.$watch(function() {\n                            if (typeof window.requestAnimationFrame === 'function') {\n                                window.requestAnimationFrame(reinitOnClientHeightChange);\n                            }\n                            else {\n                                reinitOnClientHeightChange();\n                            }\n                        });\n\n                        function updateInnerCollection() {\n                            var $scrollPosition = getScrollPos($scrollParent[0], scrollPos);\n                            var $clientSize = getClientSize($scrollParent[0], clientSize);\n\n                            var scrollOffset = repeatContainer[0] === $scrollParent[0] ? 0 : getScrollOffset(\n                                                    repeatContainer[0],\n                                                    $scrollParent[0],\n                                                    $$horizontal\n                                                );\n\n                            var __startIndex = $scope.startIndex;\n                            var __endIndex = $scope.endIndex;\n\n                            if (sizesPropertyExists) {\n                                __startIndex = 0;\n                                while ($scope.sizesCumulative[__startIndex] < $scrollPosition - $scope.offsetBefore - scrollOffset - $scope.scrollMargin) {\n                                    __startIndex++;\n                                }\n                                if (__startIndex > 0) { __startIndex--; }\n\n                                // Adjust the start index according to the excess\n                                __startIndex = Math.max(\n                                    Math.floor(__startIndex - $scope.excess / 2),\n                                    0\n                                );\n\n                                __endIndex = __startIndex;\n                                while ($scope.sizesCumulative[__endIndex] < $scrollPosition - $scope.offsetBefore - scrollOffset + $scope.scrollMargin + $clientSize) {\n                                    __endIndex++;\n                                }\n\n                                // Adjust the end index according to the excess\n                                __endIndex = Math.min(\n                                    Math.ceil(__endIndex + $scope.excess / 2),\n                                    originalLength\n                                );\n                            }\n                            else {\n                                __startIndex = Math.max(\n                                    Math.floor(\n                                        ($scrollPosition - $scope.offsetBefore - scrollOffset) / $scope.elementSize\n                                    ) - $scope.excess / 2,\n                                    0\n                                );\n\n                                __endIndex = Math.min(\n                                    __startIndex + Math.ceil(\n                                        $clientSize / $scope.elementSize\n                                    ) + $scope.excess,\n                                    originalLength\n                                );\n                            }\n\n                            _minStartIndex = Math.min(__startIndex, _minStartIndex);\n                            _maxEndIndex = Math.max(__endIndex, _maxEndIndex);\n\n                            $scope.startIndex = $$options.latch ? _minStartIndex : __startIndex;\n                            $scope.endIndex = $$options.latch ? _maxEndIndex : __endIndex;\n\n                            // Move to the end of the collection if we are now past it\n                            if (_maxEndIndex < $scope.startIndex)\n                                $scope.startIndex = _maxEndIndex;\n\n                            var digestRequired = false;\n                            if (_prevStartIndex == null) {\n                                digestRequired = true;\n                            }\n                            else if (_prevEndIndex == null) {\n                                digestRequired = true;\n                            }\n\n                            if (!digestRequired) {\n                                if ($$options.hunked) {\n                                    if (Math.abs($scope.startIndex - _prevStartIndex) >= $scope.excess / 2 ||\n                                        ($scope.startIndex === 0 && _prevStartIndex !== 0)) {\n                                        digestRequired = true;\n                                    }\n                                    else if (Math.abs($scope.endIndex - _prevEndIndex) >= $scope.excess / 2 ||\n                                        ($scope.endIndex === originalLength && _prevEndIndex !== originalLength)) {\n                                        digestRequired = true;\n                                    }\n                                }\n                                else {\n                                    digestRequired = $scope.startIndex !== _prevStartIndex ||\n                                                        $scope.endIndex !== _prevEndIndex;\n                                }\n                            }\n\n                            if (digestRequired) {\n                                $scope[collectionName] = originalCollection.slice($scope.startIndex, $scope.endIndex);\n\n                                // Emit the event\n                                $scope.$emit('vsRepeatInnerCollectionUpdated', $scope.startIndex, $scope.endIndex, _prevStartIndex, _prevEndIndex);\n                                var triggerIndex;\n                                if ($attrs.vsScrolledToEnd) {\n                                    triggerIndex = originalCollection.length - ($scope.scrolledToEndOffset || 0);\n                                    if (($scope.endIndex >= triggerIndex && _prevEndIndex < triggerIndex) || (originalCollection.length && $scope.endIndex === originalCollection.length)) {\n                                        $scope.$eval($attrs.vsScrolledToEnd);\n                                    }\n                                }\n                                if ($attrs.vsScrolledToBeginning) {\n                                    triggerIndex = $scope.scrolledToBeginningOffset || 0;\n                                    if (($scope.startIndex <= triggerIndex && _prevStartIndex > $scope.startIndex)) {\n                                        $scope.$eval($attrs.vsScrolledToBeginning);\n                                    }\n                                }\n\n                                _prevStartIndex = $scope.startIndex;\n                                _prevEndIndex = $scope.endIndex;\n\n                                var offsetCalculationString = sizesPropertyExists ?\n                                    '(sizesCumulative[$index + startIndex] + offsetBefore)' :\n                                    '(($index + startIndex) * elementSize + offsetBefore)';\n\n                                var parsed = $parse(offsetCalculationString);\n                                var o1 = parsed($scope, {$index: 0});\n                                var o2 = parsed($scope, {$index: $scope[collectionName].length});\n                                var total = $scope.totalSize;\n\n                                $beforeContent.css(getLayoutProp(), o1 + 'px');\n                                $afterContent.css(getLayoutProp(), (total - o2) + 'px');\n                            }\n\n                            return digestRequired;\n                        }\n                    }\n                };\n            }\n        };\n    }]);\n\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = vsRepeatModule.name;\n    }\n})(window, window.angular);\n","/*!\n * ngTagsInput v2.3.0\n * http://mbenford.github.io/ngTagsInput\n *\n * Copyright (c) 2013-2015 Michael Benford\n * License: MIT\n *\n * Generated at 2015-03-24 00:49:44 -0300\n */\n(function() {\n'use strict';\n\nvar KEYS = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    left: 37,\n    right: 39,\n    delete: 46,\n    comma: 188\n};\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar SUPPORTED_INPUT_TYPES = ['text', 'email', 'url'];\n\nvar tagsInput = angular.module('ngTagsInput', []);\n\n/**\n * @ngdoc directive\n * @name tagsInput\n * @module ngTagsInput\n *\n * @description\n * Renders an input box with tag editing support.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} [displayProperty=text] Property to be rendered as the tag label.\n * @param {string=} [keyProperty=text] Property to be used as a unique identifier for the tag.\n * @param {string=} [type=text] Type of the input element. Only 'text', 'email' and 'url' are supported values.\n * @param {number=} tabindex Tab order of the control.\n * @param {string=} [placeholder=Add a tag] Placeholder text for the control.\n * @param {number=} [minLength=3] Minimum length for a new tag.\n * @param {number=} [maxLength=MAX_SAFE_INTEGER] Maximum length allowed for a new tag.\n * @param {number=} [minTags=0] Sets minTags validation error key if the number of tags added is less than minTags.\n * @param {number=} [maxTags=MAX_SAFE_INTEGER] Sets maxTags validation error key if the number of tags added is greater than maxTags.\n * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in\n *                                             the input element when the directive loses focus.\n * @param {string=} [removeTagSymbol=×] Symbol character for the remove tag button.\n * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.\n * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.\n * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.\n * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.\n * @param {boolean=} [addOnPaste=false] Flag indicating that the text pasted into the input field will be split into tags.\n * @param {string=} [pasteSplitPattern=,] Regular expression used to split the pasted text into tags.\n * @param {boolean=} [replaceSpacesWithDashes=true] Flag indicating that spaces will be replaced with dashes.\n * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.\n * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into\n *                                                the new tag input box instead of being removed when the backspace key\n *                                                is pressed and the input box is empty.\n * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.\n *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and\n *                                                   allowLeftoverText values are ignored.\n * @param {boolean=} [spellcheck=true] Flag indicating whether the browser's spellcheck is enabled for the input field or not.\n * @param {expression} onTagAdding Expression to evaluate that will be invoked before adding a new tag. The new tag is available as $tag. This method must return either true or false. If false, the tag will not be added.\n * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n * @param {expression} onInvalidTag Expression to evaluate when a tag is invalid. The invalid tag is available as $tag.\n * @param {expression} onTagRemoving Expression to evaluate that will be invoked before removing a tag. The tag is available as $tag. This method must return either true or false. If false, the tag will not be removed.\n * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n */\ntagsInput.directive('tagsInput', [\"$timeout\",\"$document\",\"$window\",\"tagsInputConfig\",\"tiUtil\", function($timeout, $document, $window, tagsInputConfig, tiUtil) {\n    function TagList(options, events, onTagAdding, onTagRemoving) {\n        var self = {}, getTagText, setTagText, tagIsValid;\n\n        getTagText = function(tag) {\n            return tiUtil.safeToString(tag[options.displayProperty]);\n        };\n\n        setTagText = function(tag, text) {\n            tag[options.displayProperty] = text;\n        };\n\n        tagIsValid = function(tag) {\n            var tagText = getTagText(tag);\n\n            return tagText &&\n                   tagText.length >= options.minLength &&\n                   tagText.length <= options.maxLength &&\n                   options.allowedTagsPattern.test(tagText) &&\n                   !tiUtil.findInObjectArray(self.items, tag, options.keyProperty || options.displayProperty) &&\n                   onTagAdding({ $tag: tag });\n        };\n\n        self.items = [];\n\n        self.addText = function(text) {\n            var tag = {};\n            setTagText(tag, text);\n            return self.add(tag);\n        };\n\n        self.add = function(tag) {\n            var tagText = getTagText(tag);\n\n            if (options.replaceSpacesWithDashes) {\n                tagText = tiUtil.replaceSpacesWithDashes(tagText);\n            }\n\n            setTagText(tag, tagText);\n\n            if (tagIsValid(tag)) {\n                self.items.push(tag);\n                events.trigger('tag-added', { $tag: tag });\n            }\n            else if (tagText) {\n                events.trigger('invalid-tag', { $tag: tag });\n            }\n\n            return tag;\n        };\n\n        self.remove = function(index) {\n            var tag = self.items[index];\n\n            if (onTagRemoving({ $tag: tag }))  {\n                self.items.splice(index, 1);\n                self.clearSelection();\n                events.trigger('tag-removed', { $tag: tag });\n                return tag;\n            }\n        };\n\n        self.select = function(index) {\n            if (index < 0) {\n                index = self.items.length - 1;\n            }\n            else if (index >= self.items.length) {\n                index = 0;\n            }\n\n            self.index = index;\n            self.selected = self.items[index];\n        };\n\n        self.selectPrior = function() {\n            self.select(--self.index);\n        };\n\n        self.selectNext = function() {\n            self.select(++self.index);\n        };\n\n        self.removeSelected = function() {\n            return self.remove(self.index);\n        };\n\n        self.clearSelection = function() {\n            self.selected = null;\n            self.index = -1;\n        };\n\n        self.clearSelection();\n\n        return self;\n    }\n\n    function validateType(type) {\n        return SUPPORTED_INPUT_TYPES.indexOf(type) !== -1;\n    }\n\n    return {\n        restrict: 'E',\n        require: 'ngModel',\n        scope: {\n            tags: '=ngModel',\n            onTagAdding: '&',\n            onTagAdded: '&',\n            onInvalidTag: '&',\n            onTagRemoving: '&',\n            onTagRemoved: '&'\n        },\n        replace: false,\n        transclude: true,\n        templateUrl: 'ngTagsInput/tags-input.html',\n        controller: [\"$scope\",\"$attrs\",\"$element\", function($scope, $attrs, $element) {\n            $scope.events = tiUtil.simplePubSub();\n\n            tagsInputConfig.load('tagsInput', $scope, $attrs, {\n                template: [String, 'ngTagsInput/tag-item.html'],\n                type: [String, 'text', validateType],\n                placeholder: [String, 'Add a tag'],\n                tabindex: [Number, null],\n                removeTagSymbol: [String, String.fromCharCode(215)],\n                replaceSpacesWithDashes: [Boolean, true],\n                minLength: [Number, 3],\n                maxLength: [Number, MAX_SAFE_INTEGER],\n                addOnEnter: [Boolean, true],\n                addOnSpace: [Boolean, false],\n                addOnComma: [Boolean, true],\n                addOnBlur: [Boolean, true],\n                addOnPaste: [Boolean, false],\n                pasteSplitPattern: [RegExp, /,/],\n                allowedTagsPattern: [RegExp, /.+/],\n                enableEditingLastTag: [Boolean, false],\n                minTags: [Number, 0],\n                maxTags: [Number, MAX_SAFE_INTEGER],\n                displayProperty: [String, 'text'],\n                keyProperty: [String, ''],\n                allowLeftoverText: [Boolean, false],\n                addFromAutocompleteOnly: [Boolean, false],\n                spellcheck: [Boolean, true]\n            });\n\n            $scope.tagList = new TagList($scope.options, $scope.events,\n                tiUtil.handleUndefinedResult($scope.onTagAdding, true),\n                tiUtil.handleUndefinedResult($scope.onTagRemoving, true));\n\n            this.registerAutocomplete = function() {\n                var input = $element.find('input');\n\n                return {\n                    addTag: function(tag) {\n                        return $scope.tagList.add(tag);\n                    },\n                    focusInput: function() {\n                        // blake_r - Stop the focus as this breaks on the\n                        // version of AngularJS that ships with MAAS.\n                        //input[0].focus();\n                    },\n                    getTags: function() {\n                        return $scope.tags;\n                    },\n                    getCurrentTagText: function() {\n                        return $scope.newTag.text;\n                    },\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    on: function(name, handler) {\n                        $scope.events.on(name, handler);\n                        return this;\n                    }\n                };\n            };\n\n            this.registerTagItem = function() {\n                return {\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    removeTag: function(index) {\n                        if ($scope.disabled) {\n                            return;\n                        }\n                        $scope.tagList.remove(index);\n                    }\n                };\n            };\n        }],\n        link: function(scope, element, attrs, ngModelCtrl) {\n            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace, KEYS.delete, KEYS.left, KEYS.right],\n                tagList = scope.tagList,\n                events = scope.events,\n                options = scope.options,\n                input = element.find('input'),\n                validationOptions = ['minTags', 'maxTags', 'allowLeftoverText'],\n                setElementValidity;\n\n            setElementValidity = function() {\n                ngModelCtrl.$setValidity('maxTags', scope.tags.length <= options.maxTags);\n                ngModelCtrl.$setValidity('minTags', scope.tags.length >= options.minTags);\n                ngModelCtrl.$setValidity('leftoverText', scope.hasFocus || options.allowLeftoverText ? true : !scope.newTag.text);\n            };\n\n            ngModelCtrl.$isEmpty = function(value) {\n                return !value || !value.length;\n            };\n\n            scope.newTag = {\n                text: '',\n                invalid: null,\n                setText: function(value) {\n                    this.text = value;\n                    events.trigger('input-change', value);\n                }\n            };\n\n            scope.track = function(tag) {\n                return tag[options.keyProperty || options.displayProperty];\n            };\n\n            scope.$watch('tags', function(value) {\n                scope.tags = tiUtil.makeObjectArray(value, options.displayProperty);\n                tagList.items = scope.tags;\n            });\n\n            scope.$watch('tags.length', function() {\n                setElementValidity();\n            });\n\n            attrs.$observe('disabled', function(value) {\n                scope.disabled = value;\n            });\n\n            scope.eventHandlers = {\n                input: {\n                    change: function(text) {\n                        events.trigger('input-change', text);\n                    },\n                    keydown: function($event) {\n                        events.trigger('input-keydown', $event);\n                    },\n                    focus: function() {\n                        if (scope.hasFocus) {\n                            return;\n                        }\n\n                        scope.hasFocus = true;\n                        events.trigger('input-focus');\n                    },\n                    blur: function() {\n                        $timeout(function() {\n                            var activeElement = $document.prop('activeElement'),\n                                lostFocusToBrowserWindow = activeElement === input[0],\n                                lostFocusToChildElement = element[0].contains(activeElement);\n\n                            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {\n                                scope.hasFocus = false;\n                                events.trigger('input-blur');\n                            }\n                        });\n                    },\n                    paste: function($event) {\n                        $event.getTextData = function() {\n                            var clipboardData = $event.clipboardData || ($event.originalEvent && $event.originalEvent.clipboardData);\n                            return clipboardData ? clipboardData.getData('text/plain') : $window.clipboardData.getData('Text');\n                        };\n                        events.trigger('input-paste', $event);\n                    }\n                },\n                host: {\n                    click: function() {\n                        if (scope.disabled) {\n                            return;\n                        }\n                        // blake_r - Stop the focus as this breaks on the\n                        // version of AngularJS that ships with MAAS.\n                        //input[0].focus();\n                    }\n                }\n            };\n\n            events\n                .on('tag-added', scope.onTagAdded)\n                .on('invalid-tag', scope.onInvalidTag)\n                .on('tag-removed', scope.onTagRemoved)\n                .on('tag-added', function() {\n                    scope.newTag.setText('');\n                })\n                .on('tag-added tag-removed', function() {\n                    // Sets the element to its dirty state\n                    // In Angular 1.3 this will be replaced with $setDirty.\n                    ngModelCtrl.$setViewValue(scope.tags);\n                })\n                .on('invalid-tag', function() {\n                    scope.newTag.invalid = true;\n                })\n                .on('option-change', function(e) {\n                    if (validationOptions.indexOf(e.name) !== -1) {\n                        setElementValidity();\n                    }\n                })\n                .on('input-change', function() {\n                    tagList.clearSelection();\n                    scope.newTag.invalid = null;\n                })\n                .on('input-focus', function() {\n                    element.triggerHandler('focus');\n                    ngModelCtrl.$setValidity('leftoverText', true);\n                })\n                .on('input-blur', function() {\n                    if (options.addOnBlur && !options.addFromAutocompleteOnly) {\n                        tagList.addText(scope.newTag.text);\n                    }\n                    element.triggerHandler('blur');\n                    setElementValidity();\n                })\n                .on('input-keydown', function(event) {\n                    var key = event.keyCode,\n                        isModifier = event.shiftKey || event.altKey || event.ctrlKey || event.metaKey,\n                        addKeys = {},\n                        shouldAdd, shouldRemove, shouldSelect, shouldEditLastTag;\n\n                    if (isModifier || hotkeys.indexOf(key) === -1) {\n                        return;\n                    }\n\n                    addKeys[KEYS.enter] = options.addOnEnter;\n                    addKeys[KEYS.comma] = options.addOnComma;\n                    addKeys[KEYS.space] = options.addOnSpace;\n\n                    shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];\n                    shouldRemove = (key === KEYS.backspace || key === KEYS.delete) && tagList.selected;\n                    shouldEditLastTag = key === KEYS.backspace && scope.newTag.text.length === 0 && options.enableEditingLastTag;\n                    shouldSelect = (key === KEYS.backspace || key === KEYS.left || key === KEYS.right) && scope.newTag.text.length === 0 && !options.enableEditingLastTag;\n\n                    if (shouldAdd) {\n                        tagList.addText(scope.newTag.text);\n                    }\n                    else if (shouldEditLastTag) {\n                        var tag;\n\n                        tagList.selectPrior();\n                        tag = tagList.removeSelected();\n\n                        if (tag) {\n                            scope.newTag.setText(tag[options.displayProperty]);\n                        }\n                    }\n                    else if (shouldRemove) {\n                        tagList.removeSelected();\n                    }\n                    else if (shouldSelect) {\n                        if (key === KEYS.left || key === KEYS.backspace) {\n                            tagList.selectPrior();\n                        }\n                        else if (key === KEYS.right) {\n                            tagList.selectNext();\n                        }\n                    }\n\n                    if (shouldAdd || shouldSelect || shouldRemove || shouldEditLastTag) {\n                        event.preventDefault();\n                    }\n                })\n                .on('input-paste', function(event) {\n                    if (options.addOnPaste) {\n                        var data = event.getTextData();\n                        var tags = data.split(options.pasteSplitPattern);\n\n                        if (tags.length > 1) {\n                            tags.forEach(function(tag) {\n                                tagList.addText(tag);\n                            });\n                            event.preventDefault();\n                        }\n                    }\n                });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiTagItem\n * @module ngTagsInput\n *\n * @description\n * Represents a tag item. Used internally by the tagsInput directive.\n */\ntagsInput.directive('tiTagItem', [\"tiUtil\", function(tiUtil) {\n    return {\n        restrict: 'E',\n        require: '^tagsInput',\n        template: '<ng-include src=\"$$template\"></ng-include>',\n        scope: { data: '=' },\n        link: function(scope, element, attrs, tagsInputCtrl) {\n            var tagsInput = tagsInputCtrl.registerTagItem(),\n                options = tagsInput.getOptions();\n\n            scope.$$template = options.template;\n            scope.$$removeTagSymbol = options.removeTagSymbol;\n\n            scope.$getDisplayText = function() {\n                return tiUtil.safeToString(scope.data[options.displayProperty]);\n            };\n            scope.$removeTag = function() {\n                tagsInput.removeTag(scope.$index);\n            };\n\n            scope.$watch('$parent.$index', function(value) {\n                scope.$index = value;\n            });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name autoComplete\n * @module ngTagsInput\n *\n * @description\n * Provides autocomplete support for the tagsInput directive.\n *\n * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as\n *                            $query. The result of the expression must be a promise that eventually resolves to an\n *                            array of strings.\n * @param {string=} [displayProperty=text] Property to be rendered as the autocomplete label.\n * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in\n *                                      the source option after the last keystroke.\n * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression\n *                                 in the source option.\n * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the\n *                                               suggestions list.\n * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.\n * @param {boolean=} [loadOnDownArrow=false] Flag indicating that the source option will be evaluated when the down arrow\n *                                           key is pressed and the suggestion list is closed. The current input value\n *                                           is available as $query.\n * @param {boolean=} {loadOnEmpty=false} Flag indicating that the source option will be evaluated when the input content\n *                                       becomes empty. The $query variable will be passed to the expression as an empty string.\n * @param {boolean=} {loadOnFocus=false} Flag indicating that the source option will be evaluated when the input element\n *                                       gains focus. The current input value is available as $query.\n * @param {boolean=} [selectFirstMatch=true] Flag indicating that the first match will be automatically selected once\n *                                           the suggestion list is shown.\n * @param {string=} [template=] URL or id of a custom template for rendering each element of the autocomplete list.\n */\ntagsInput.directive('autoComplete', [\"$document\",\"$timeout\",\"$sce\",\"$q\",\"tagsInputConfig\",\"tiUtil\", function($document, $timeout, $sce, $q, tagsInputConfig, tiUtil) {\n    function SuggestionList(loadFn, options, events) {\n        var self = {}, getDifference, lastPromise, getTagId;\n\n        getTagId = function() {\n            return options.tagsInput.keyProperty || options.tagsInput.displayProperty;\n        };\n\n        getDifference = function(array1, array2) {\n            return array1.filter(function(item) {\n                return !tiUtil.findInObjectArray(array2, item, getTagId(), function(a, b) {\n                    if (options.tagsInput.replaceSpacesWithDashes) {\n                        a = tiUtil.replaceSpacesWithDashes(a);\n                        b = tiUtil.replaceSpacesWithDashes(b);\n                    }\n                    return tiUtil.defaultComparer(a, b);\n                });\n            });\n        };\n\n        self.reset = function() {\n            lastPromise = null;\n\n            self.items = [];\n            self.visible = false;\n            self.index = -1;\n            self.selected = null;\n            self.query = null;\n        };\n        self.show = function() {\n            if (options.selectFirstMatch) {\n                self.select(0);\n            }\n            else {\n                self.selected = null;\n            }\n            self.visible = true;\n        };\n        self.load = tiUtil.debounce(function(query, tags) {\n            self.query = query;\n\n            var promise = $q.when(loadFn({ $query: query }));\n            lastPromise = promise;\n\n            promise.then(function(items) {\n                if (promise !== lastPromise) {\n                    return;\n                }\n\n                items = tiUtil.makeObjectArray(items.data || items, getTagId());\n                items = getDifference(items, tags);\n                self.items = items.slice(0, options.maxResultsToShow);\n\n                if (self.items.length > 0) {\n                    self.show();\n                }\n                else {\n                    self.reset();\n                }\n            });\n        }, options.debounceDelay);\n\n        self.selectNext = function() {\n            self.select(++self.index);\n        };\n        self.selectPrior = function() {\n            self.select(--self.index);\n        };\n        self.select = function(index) {\n            if (index < 0) {\n                index = self.items.length - 1;\n            }\n            else if (index >= self.items.length) {\n                index = 0;\n            }\n            self.index = index;\n            self.selected = self.items[index];\n            events.trigger('suggestion-selected', index);\n        };\n\n        self.reset();\n\n        return self;\n    }\n\n    function scrollToElement(root, index) {\n        var element = root.find('li').eq(index),\n            parent = element.parent(),\n            elementTop = element.prop('offsetTop'),\n            elementHeight = element.prop('offsetHeight'),\n            parentHeight = parent.prop('clientHeight'),\n            parentScrollTop = parent.prop('scrollTop');\n\n        if (elementTop < parentScrollTop) {\n            parent.prop('scrollTop', elementTop);\n        }\n        else if (elementTop + elementHeight > parentHeight + parentScrollTop) {\n            parent.prop('scrollTop', elementTop + elementHeight - parentHeight);\n        }\n    }\n\n    return {\n        restrict: 'E',\n        require: '^tagsInput',\n        scope: { source: '&' },\n        templateUrl: 'ngTagsInput/auto-complete.html',\n        controller: [\"$scope\",\"$element\",\"$attrs\", function($scope, $element, $attrs) {\n            $scope.events = tiUtil.simplePubSub();\n\n            tagsInputConfig.load('autoComplete', $scope, $attrs, {\n                template: [String, 'ngTagsInput/auto-complete-match.html'],\n                debounceDelay: [Number, 100],\n                minLength: [Number, 3],\n                highlightMatchedText: [Boolean, true],\n                maxResultsToShow: [Number, 10],\n                loadOnDownArrow: [Boolean, false],\n                loadOnEmpty: [Boolean, false],\n                loadOnFocus: [Boolean, false],\n                selectFirstMatch: [Boolean, true],\n                displayProperty: [String, '']\n            });\n\n            $scope.suggestionList = new SuggestionList($scope.source, $scope.options, $scope.events);\n            $scope.getCurrentTag = function() {\n                return $scope.$parent.$parent.newTag.text;\n            };\n\n            $scope.addTag = function(tag) {\n                $scope.$parent.$parent.tagList.items.push({ text: tag });\n                $scope.$parent.$parent.newTag.setText('');\n            };\n\n            this.registerAutocompleteMatch = function() {\n                return {\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    getQuery: function() {\n                        return $scope.suggestionList.query;\n                    }\n                };\n            };\n        }],\n        link: function(scope, element, attrs, tagsInputCtrl) {\n            var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],\n                suggestionList = scope.suggestionList,\n                tagsInput = tagsInputCtrl.registerAutocomplete(),\n                options = scope.options,\n                events = scope.events,\n                shouldLoadSuggestions;\n\n            options.tagsInput = tagsInput.getOptions();\n\n            shouldLoadSuggestions = function(value) {\n                return value && value.length >= options.minLength || !value && options.loadOnEmpty;\n            };\n\n            scope.addSuggestionByIndex = function(index) {\n                suggestionList.select(index);\n                scope.addSuggestion();\n            };\n\n            scope.addSuggestion = function() {\n                var added = false;\n\n                if (suggestionList.selected) {\n                    tagsInput.addTag(angular.copy(suggestionList.selected));\n                    suggestionList.reset();\n                    tagsInput.focusInput();\n\n                    added = true;\n                }\n                return added;\n            };\n\n            scope.track = function(item) {\n                return item[options.tagsInput.keyProperty || options.tagsInput.displayProperty];\n            };\n\n            tagsInput\n                .on('tag-added invalid-tag input-blur', function() {\n                    suggestionList.reset();\n                })\n                .on('input-change', function(value) {\n                    if (shouldLoadSuggestions(value)) {\n                        suggestionList.load(value, tagsInput.getTags());\n                    }\n                    else {\n                        suggestionList.reset();\n                    }\n                })\n                .on('input-focus', function() {\n                    var value = tagsInput.getCurrentTagText();\n                    scope.hasFocus = true;\n                    scope.shouldLoadSuggestions = shouldLoadSuggestions(value);\n                    if (options.loadOnFocus && scope.shouldLoadSuggestions) {\n                        suggestionList.load(value, tagsInput.getTags());\n                    }\n                })\n                .on('input-keydown', function(event) {\n                    var key = event.keyCode,\n                        handled = false;\n\n                    if (hotkeys.indexOf(key) === -1) {\n                        return;\n                    }\n\n                    if (suggestionList.visible) {\n\n                        if (key === KEYS.down) {\n                            suggestionList.selectNext();\n                            handled = true;\n                        }\n                        else if (key === KEYS.up) {\n                            suggestionList.selectPrior();\n                            handled = true;\n                        }\n                        else if (key === KEYS.escape) {\n                            suggestionList.reset();\n                            handled = true;\n                        }\n                        else if (key === KEYS.enter || key === KEYS.tab) {\n                            handled = scope.addSuggestion();\n                        }\n                    }\n                    else {\n                        if (key === KEYS.down && scope.options.loadOnDownArrow) {\n                            suggestionList.load(tagsInput.getCurrentTagText(), tagsInput.getTags());\n                            handled = true;\n                        }\n                    }\n\n                    if (handled) {\n                        event.preventDefault();\n                        event.stopImmediatePropagation();\n                        return false;\n                    }\n                })\n                .on('input-blur', function() {\n                    scope.hasFocus = false;\n                });\n\n            events.on('suggestion-selected', function(index) {\n                scrollToElement(element, index);\n            });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiAutocompleteMatch\n * @module ngTagsInput\n *\n * @description\n * Represents an autocomplete match. Used internally by the autoComplete directive.\n */\ntagsInput.directive('tiAutocompleteMatch', [\"$sce\",\"tiUtil\", function($sce, tiUtil) {\n    return {\n        restrict: 'E',\n        require: '^autoComplete',\n        template: '<ng-include src=\"$$template\"></ng-include>',\n        scope: { data: '=' },\n        link: function(scope, element, attrs, autoCompleteCtrl) {\n            var autoComplete = autoCompleteCtrl.registerAutocompleteMatch(),\n                options = autoComplete.getOptions();\n\n            scope.$$template = options.template;\n            scope.$index = scope.$parent.$index;\n\n            scope.$highlight = function(text) {\n                if (options.highlightMatchedText) {\n                    text = tiUtil.safeHighlight(text, autoComplete.getQuery());\n                }\n                return $sce.trustAsHtml(text);\n            };\n            scope.$getDisplayText =  function() {\n                return tiUtil.safeToString(scope.data[options.displayProperty || options.tagsInput.displayProperty]);\n            };\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiTranscludeAppend\n * @module ngTagsInput\n *\n * @description\n * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiTranscludeAppend', function() {\n    return function(scope, element, attrs, ctrl, transcludeFn) {\n        transcludeFn(function(clone) {\n            element.append(clone);\n        });\n    };\n});\n\n/**\n * @ngdoc directive\n * @name tiAutosize\n * @module ngTagsInput\n *\n * @description\n * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiAutosize', [\"tagsInputConfig\", function(tagsInputConfig) {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function(scope, element, attrs, ctrl) {\n            var threshold = tagsInputConfig.getTextAutosizeThreshold(),\n                span, resize;\n\n            span = angular.element('<span class=\"input\"></span>');\n            span.css('display', 'none')\n                .css('visibility', 'hidden')\n                .css('width', 'auto')\n                .css('white-space', 'pre');\n\n            element.parent().append(span);\n\n            resize = function(originalValue) {\n                var value = originalValue, width;\n\n                if (angular.isString(value) && value.length === 0) {\n                    value = attrs.placeholder;\n                }\n\n                if (value) {\n                    span.text(value);\n                    span.css('display', '');\n                    width = span.prop('offsetWidth');\n                    span.css('display', 'none');\n                }\n\n                element.css('width', width ? width + threshold + 'px' : '');\n\n                return originalValue;\n            };\n\n            ctrl.$parsers.unshift(resize);\n            ctrl.$formatters.unshift(resize);\n\n            attrs.$observe('placeholder', function(value) {\n                if (!ctrl.$modelValue) {\n                    resize(value);\n                }\n            });\n        }\n    };\n}]);\n\n/**\n * @ngdoc directive\n * @name tiBindAttrs\n * @module ngTagsInput\n *\n * @description\n * Binds attributes to expressions. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiBindAttrs', function() {\n    return function(scope, element, attrs) {\n        scope.$watch(attrs.tiBindAttrs, function(value) {\n            angular.forEach(value, function(value, key) {\n                /**\n                 * blake_r - Added to work around the version of jQuery that\n                 * MAAS currently ships with. Once packaging for jQuery is\n                 * version >1.9 this can be removed.\n                 */\n                if(key === \"type\") {\n                    element[0].type = value;\n                } else {\n                    attrs.$set(key, value);\n                }\n            });\n        }, true);\n    };\n});\n\n/**\n * @ngdoc service\n * @name tagsInputConfig\n * @module ngTagsInput\n *\n * @description\n * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and\n * initialize options from HTML attributes.\n */\ntagsInput.provider('tagsInputConfig', function() {\n    var globalDefaults = {},\n        interpolationStatus = {},\n        autosizeThreshold = 3;\n\n    /**\n     * @ngdoc method\n     * @name setDefaults\n     * @description Sets the default configuration option for a directive.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} defaults Object containing options and their values.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setDefaults = function(directive, defaults) {\n        globalDefaults[directive] = defaults;\n        return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setActiveInterpolation\n     * @description Sets active interpolation for a set of options.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} options Object containing which options should have interpolation turned on at all times.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setActiveInterpolation = function(directive, options) {\n        interpolationStatus[directive] = options;\n        return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setTextAutosizeThreshold\n     * @description Sets the threshold used by the tagsInput directive to re-size the inner input field element based on its contents.\n     * @methodOf tagsInputConfig\n     *\n     * @param {number} threshold Threshold value, in pixels.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setTextAutosizeThreshold = function(threshold) {\n        autosizeThreshold = threshold;\n        return this;\n    };\n\n    this.$get = [\"$interpolate\", function($interpolate) {\n        var converters = {};\n        converters[String] = function(value) { return value; };\n        converters[Number] = function(value) { return parseInt(value, 10); };\n        converters[Boolean] = function(value) { return value.toLowerCase() === 'true'; };\n        converters[RegExp] = function(value) { return new RegExp(value); };\n\n        return {\n            load: function(directive, scope, attrs, options) {\n                var defaultValidator = function() { return true; };\n\n                scope.options = {};\n\n                angular.forEach(options, function(value, key) {\n                    var type, localDefault, validator, converter, getDefault, updateValue;\n\n                    type = value[0];\n                    localDefault = value[1];\n                    validator = value[2] || defaultValidator;\n                    converter = converters[type];\n\n                    getDefault = function() {\n                        var globalValue = globalDefaults[directive] && globalDefaults[directive][key];\n                        return angular.isDefined(globalValue) ? globalValue : localDefault;\n                    };\n\n                    updateValue = function(value) {\n                        scope.options[key] = value && validator(value) ? converter(value) : getDefault();\n                    };\n\n                    if (interpolationStatus[directive] && interpolationStatus[directive][key]) {\n                        attrs.$observe(key, function(value) {\n                            updateValue(value);\n                            scope.events.trigger('option-change', { name: key, newValue: value });\n                        });\n                    }\n                    else {\n                        updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));\n                    }\n                });\n            },\n            getTextAutosizeThreshold: function() {\n                return autosizeThreshold;\n            }\n        };\n    }];\n});\n\n\n/***\n * @ngdoc factory\n * @name tiUtil\n * @module ngTagsInput\n *\n * @description\n * Helper methods used internally by the directive. Should not be called directly from user code.\n */\ntagsInput.factory('tiUtil', [\"$timeout\", function($timeout) {\n    var self = {};\n\n    self.debounce = function(fn, delay) {\n        var timeoutId;\n        return function() {\n            var args = arguments;\n            $timeout.cancel(timeoutId);\n            timeoutId = $timeout(function() { fn.apply(null, args); }, delay);\n        };\n    };\n\n    self.makeObjectArray = function(array, key) {\n        array = array || [];\n        if (array.length > 0 && !angular.isObject(array[0])) {\n            array.forEach(function(item, index) {\n                array[index] = {};\n                array[index][key] = item;\n            });\n        }\n        return array;\n    };\n\n    self.findInObjectArray = function(array, obj, key, comparer) {\n        var item = null;\n        comparer = comparer || self.defaultComparer;\n\n        array.some(function(element) {\n            if (comparer(element[key], obj[key])) {\n                item = element;\n                return true;\n            }\n        });\n\n        return item;\n    };\n\n    self.defaultComparer = function(a, b) {\n        // I'm aware of the internationalization issues regarding toLowerCase()\n        // but I couldn't come up with a better solution right now\n        return self.safeToString(a).toLowerCase() === self.safeToString(b).toLowerCase();\n    };\n\n    self.safeHighlight = function(str, value) {\n        if (!value) {\n            return str;\n        }\n\n        function escapeRegexChars(str) {\n            return str.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n        }\n\n        str = self.encodeHTML(str);\n        value = self.encodeHTML(value);\n\n        var expression = new RegExp('&[^;]+;|' + escapeRegexChars(value), 'gi');\n        return str.replace(expression, function(match) {\n            return match.toLowerCase() === value.toLowerCase() ? '<em>' + match + '</em>' : match;\n        });\n    };\n\n    self.safeToString = function(value) {\n        return angular.isUndefined(value) || value == null ? '' : value.toString().trim();\n    };\n\n    self.encodeHTML = function(value) {\n        return self.safeToString(value)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    };\n\n    self.handleUndefinedResult = function(fn, valueIfUndefined) {\n        return function() {\n            var result = fn.apply(null, arguments);\n            return angular.isUndefined(result) ? valueIfUndefined : result;\n        };\n    };\n\n    self.replaceSpacesWithDashes = function(str) {\n        return self.safeToString(str).replace(/\\s/g, '-');\n    };\n\n    self.simplePubSub = function() {\n        var events = {};\n        return {\n            on: function(names, handler) {\n                names.split(' ').forEach(function(name) {\n                    if (!events[name]) {\n                        events[name] = [];\n                    }\n                    events[name].push(handler);\n                });\n                return this;\n            },\n            trigger: function(name, args) {\n                var handlers = events[name] || [];\n                handlers.every(function(handler) {\n                    return self.handleUndefinedResult(handler, true)(args);\n                });\n                return this;\n            }\n        };\n    };\n\n    return self;\n}]);\n\n/* HTML templates */\ntagsInput.run([\"$templateCache\", function($templateCache) {\n    $templateCache.put('ngTagsInput/tags-input.html',\n    '<div class=\"host\" tabindex=\"-1\" data-ng-click=\"eventHandlers.host.click()\" ti-transclude-append=\"\">' +\n    '<div class=\"tags\" data-ng-class=\"{focused: hasFocus}\">' +\n    '<ul class=\"tag-list\">' +\n    '<li class=\"tag-item\" data-ng-repeat=\"tag in tagList.items track by track(tag)\" data-ng-class=\"{ selected: tag == tagList.selected }\">' +\n    '<ti-tag-item data=\"tag\"></ti-tag-item>' +\n    '</li>' +\n    '</ul>' +\n    '<input class=\"input u-no-margin--top u-no-margin--bottom\" autocomplete=\"off\" data-ng-model=\"newTag.text\" data-ng-change=\"eventHandlers.input.change(newTag.text)\" data-ng-keydown=\"eventHandlers.input.keydown($event)\" data-ng-focus=\"eventHandlers.input.focus($event)\" data-ng-blur=\"eventHandlers.input.blur($event)\" data-ng-paste=\"eventHandlers.input.paste($event)\" data-ng-trim=\"false\" data-ng-class=\"{\\'invalid-tag\\': newTag.invalid}\" data-ng-disabled=\"disabled\" ti-bind-attrs=\"{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex, spellcheck: options.spellcheck}\" ti-autosize=\"\">' +\n    '</div>' +\n    '</div>'\n  );\n\n  $templateCache.put('ngTagsInput/tag-item.html',\n    '<span ng-bind=\"$getDisplayText()\"></span> ' +\n    '<a class=\"p-icon--close\" data-ng-click=\"$removeTag()\" data-ng-bind=\"$$removeTagSymbol\">' +\n    'Remove tag' +\n    '</a>'\n  );\n\n  $templateCache.put('ngTagsInput/auto-complete.html',\n    '<div class=\"autocomplete\" data-ng-if=\"suggestionList.visible\">' +\n    '<ul class=\"p-list suggestion-list\">' +\n    '<li class=\"suggestion-item create-tag-label\" data-ng-if=\"getCurrentTag().length\">' +\n    '<span data-ng-click=\"addTag(getCurrentTag())\">Create new tag</span> <span class=\"tag-item\">{$ getCurrentTag() $}</span>' +\n    '</li>' +\n    '<li class=\"suggestion-item\" data-ng-repeat=\"item in suggestionList.items track by track(item)\" data-ng-class=\"{selected: item == suggestionList.selected}\" data-ng-click=\"addSuggestionByIndex($index)\" data-ng-mouseenter=\"suggestionList.select($index)\">' +\n    '<ti-autocomplete-match data=\"item\"></ti-autocomplete-match>' +\n    '</li>' +\n    '</ul>' +\n    '</div>' +\n    '<div class=\"autocomplete no-suggestion\" data-ng-if=\"!suggestionList.visible && hasFocus && shouldLoadSuggestions && getCurrentTag().length\">' +\n    '<ul class=\"p-list suggestion-list\">' +\n    '<li class=\"suggestion-item create-tag-label\" data-ng-if=\"getCurrentTag().length\">' +\n    '<span data-ng-click=\"addTag(getCurrentTag())\">Create new tag</span> <span class=\"tag-item\">{$ getCurrentTag() $}</span>' +\n    '</li>' +\n    '</ul>' +\n    '</div>'\n  );\n\n  $templateCache.put('ngTagsInput/auto-complete-match.html',\n    '<span data-ng-bind-html=\"$highlight($getDisplayText())\"></span>'\n  );\n}]);\n\n}());\n"],"sourceRoot":""}
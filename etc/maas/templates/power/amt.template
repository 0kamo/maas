#!/bin/sh
# -*- mode: shell-script -*-
#
# Control a system via amttool
#
# Parameters.  Don't quote these: the templating system will quote as needed,
# so adding quotes of our own might cause double-quoting.
# Exit code:
# 0: success
# 1: failure (might be temporary, worth retrying)
# 2: fatal failure (not worth retrying, see error message for details)
power_address={{power_address}}
power_change={{power_change}}
power_pass={{power_pass}}
ip_address={{ip_address}}

# The user specified power_address overrides any automatically determined
# ip_address.
if [ -n "$power_address" ]; then
  ip_address=$power_address
fi


# Exit with failure message.
# Parameters: exit code, and error message.
# Fail with exit code 1 to ask for a retry, exit code 2 for a hard fail.
fail() {
    echo "$2" >&2
    exit $1
}


# Perform a command using amttool.
issue_amt_command() {
  LC_ALL='C' AMT_PASSWORD="$power_pass" amttool "$ip_address" "$@" || fail 1 "amttool failure"
    # Stderr will be caught by the power driver, no need to repeat it.
}

# Check that amttool is present.
check_amt_command() {
  command -v amttool >/dev/null 2>&1 || { fail 2 "Missing amttool (amtterm package)"; }
}

# Check that a node host has been passed.
check_bmc_host() {
  if [ -z "$ip_address" ]; then
    # This usually happens when the MAC address of the BMC is being used
    # and the ARP cache (used to find the BMC IP) isn't primed.
    # See https://bugs.launchpad.net/maas/+bug/1279460 for details.
    fail 2 "No host provided"
  fi
}

# Ask for node's power state: 'on' or 'off'.
query_state() {
    # Retry the state if it fails because it often fails the first time.
    local state=
    local count=
    state=$(issue_amt_command info | grep '^Powerstate:' | awk '{print $2}')
    if [ -n "$state" ]
    then
        break
    fi
    # Wait 1 second between queries  AMT controllers are generally very
    # light and may not be comfortable with more frequent queries.
    sleep 1
    case "$state" in
    S[0-4])
        # Wide awake (S0), or asleep (S1-S4), but not a clean slate that
        # will lead to a fresh boot.
        echo 'on'
        ;;
    S5)
        echo 'off'
        ;;
    *)
        fail 2 "Got unknown power state from node: '$state'"
        ;;
    esac
}


# Power-cycle the machine, and boot it using PXE.
restart() {
    issue_amt_command powercycle pxe
}


# Power the machine on, and boot it using PXE.
power_on() {
    local attempts=
    # Do not retry here, it's handled in the core power driver.
    # Issue the AMT command; amttool will prompt for confirmation.
    yes | issue_amt_command powerup pxe
    sleep 1
    if [ "$(query_state)" = 'on' ]
    then
        # Success.  Machine is on.
        return 0
    fi
    fail 1 "Machine is not powering on.  Giving up."
}


# Power the machine off.
power_off() {
    local attempts=
    # Do not retry here, it's handled in the core power driver.
    # Issue the AMT command; amttool will prompt for confirmation.
    yes | issue_amt_command powerdown
    sleep 1
    if [ "$(query_state)" = 'off' ]
    then
        # Success.  Machine is off.
        return 0
    fi

    fail 1 "Machine is not powering off.  Giving up."
}


main() {
    check_bmc_host
    check_amt_command
    case "${power_change}" in
    'on')
        if [ "$(query_state)" = 'on' ]
        then
            # The machine is already up, so powering it up will do nothing.
            # Cycle the power instead.
            restart
        else
            power_on
        fi
        ;;
    'off')
        if [ "$(query_state)" != 'off' ]
        then
            power_off
        fi
        ;;
    'query')
        query_state
        ;;
    *)
        fail 1 "Unknown power command: '$1'"
    esac
}

main "$power_change"
